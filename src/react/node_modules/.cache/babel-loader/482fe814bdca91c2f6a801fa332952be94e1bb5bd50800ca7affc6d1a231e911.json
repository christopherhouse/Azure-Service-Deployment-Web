{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { setContinuationToken } from \"../pagingHelper.js\";\nimport * as coreClient from \"@azure/core-client\";\nimport * as Mappers from \"../models/mappers.js\";\nimport * as Parameters from \"../models/parameters.js\";\nimport { createHttpPoller } from \"@azure/core-lro\";\nimport { createLroSpec } from \"../lroImpl.js\";\n/// <reference lib=\"esnext.asynciterable\" />\n/** Class containing Resources operations. */\nexport class ResourcesImpl {\n  /**\n   * Initialize a new instance of the class Resources class.\n   * @param client Reference to the service client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * Get all the resources for a resource group.\n   * @param resourceGroupName The resource group with the resources to get.\n   * @param options The options parameters.\n   */\n  listByResourceGroup(resourceGroupName, options) {\n    const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: settings => {\n        if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);\n      }\n    };\n  }\n  listByResourceGroupPagingPage(resourceGroupName, options, settings) {\n    return __asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {\n      let result;\n      let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;\n      if (!continuationToken) {\n        result = yield __await(this._listByResourceGroup(resourceGroupName, options));\n        let page = result.value || [];\n        continuationToken = result.nextLink;\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n      while (continuationToken) {\n        result = yield __await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));\n        continuationToken = result.nextLink;\n        let page = result.value || [];\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n    });\n  }\n  listByResourceGroupPagingAll(resourceGroupName, options) {\n    return __asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {\n      var _a, e_1, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  /**\n   * Get all the resources in a subscription.\n   * @param options The options parameters.\n   */\n  list(options) {\n    const iter = this.listPagingAll(options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: settings => {\n        if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listPagingPage(options, settings);\n      }\n    };\n  }\n  listPagingPage(options, settings) {\n    return __asyncGenerator(this, arguments, function* listPagingPage_1() {\n      let result;\n      let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;\n      if (!continuationToken) {\n        result = yield __await(this._list(options));\n        let page = result.value || [];\n        continuationToken = result.nextLink;\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n      while (continuationToken) {\n        result = yield __await(this._listNext(continuationToken, options));\n        continuationToken = result.nextLink;\n        let page = result.value || [];\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n    });\n  }\n  listPagingAll(options) {\n    return __asyncGenerator(this, arguments, function* listPagingAll_1() {\n      var _a, e_2, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listPagingPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  /**\n   * Get all the resources for a resource group.\n   * @param resourceGroupName The resource group with the resources to get.\n   * @param options The options parameters.\n   */\n  _listByResourceGroup(resourceGroupName, options) {\n    return this.client.sendOperationRequest({\n      resourceGroupName,\n      options\n    }, listByResourceGroupOperationSpec);\n  }\n  /**\n   * The resources to be moved must be in the same source resource group in the source subscription being\n   * used. The target resource group may be in a different subscription. When moving resources, both the\n   * source group and the target group are locked for the duration of the operation. Write and delete\n   * operations are blocked on the groups until the move completes.\n   * @param sourceResourceGroupName The name of the resource group from the source subscription\n   *                                containing the resources to be moved.\n   * @param parameters Parameters for moving resources.\n   * @param options The options parameters.\n   */\n  async beginMoveResources(sourceResourceGroupName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        sourceResourceGroupName,\n        parameters,\n        options\n      },\n      spec: moveResourcesOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * The resources to be moved must be in the same source resource group in the source subscription being\n   * used. The target resource group may be in a different subscription. When moving resources, both the\n   * source group and the target group are locked for the duration of the operation. Write and delete\n   * operations are blocked on the groups until the move completes.\n   * @param sourceResourceGroupName The name of the resource group from the source subscription\n   *                                containing the resources to be moved.\n   * @param parameters Parameters for moving resources.\n   * @param options The options parameters.\n   */\n  async beginMoveResourcesAndWait(sourceResourceGroupName, parameters, options) {\n    const poller = await this.beginMoveResources(sourceResourceGroupName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * This operation checks whether the specified resources can be moved to the target. The resources to\n   * be moved must be in the same source resource group in the source subscription being used. The target\n   * resource group may be in a different subscription. If validation succeeds, it returns HTTP response\n   * code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an\n   * error message. Retrieve the URL in the Location header value to check the result of the long-running\n   * operation.\n   * @param sourceResourceGroupName The name of the resource group from the source subscription\n   *                                containing the resources to be validated for move.\n   * @param parameters Parameters for moving resources.\n   * @param options The options parameters.\n   */\n  async beginValidateMoveResources(sourceResourceGroupName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        sourceResourceGroupName,\n        parameters,\n        options\n      },\n      spec: validateMoveResourcesOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * This operation checks whether the specified resources can be moved to the target. The resources to\n   * be moved must be in the same source resource group in the source subscription being used. The target\n   * resource group may be in a different subscription. If validation succeeds, it returns HTTP response\n   * code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an\n   * error message. Retrieve the URL in the Location header value to check the result of the long-running\n   * operation.\n   * @param sourceResourceGroupName The name of the resource group from the source subscription\n   *                                containing the resources to be validated for move.\n   * @param parameters Parameters for moving resources.\n   * @param options The options parameters.\n   */\n  async beginValidateMoveResourcesAndWait(sourceResourceGroupName, parameters, options) {\n    const poller = await this.beginValidateMoveResources(sourceResourceGroupName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Get all the resources in a subscription.\n   * @param options The options parameters.\n   */\n  _list(options) {\n    return this.client.sendOperationRequest({\n      options\n    }, listOperationSpec);\n  }\n  /**\n   * Checks whether a resource exists.\n   * @param resourceGroupName The name of the resource group containing the resource to check. The name\n   *                          is case insensitive.\n   * @param resourceProviderNamespace The resource provider of the resource to check.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type.\n   * @param resourceName The name of the resource to check whether it exists.\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  checkExistence(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, options) {\n    return this.client.sendOperationRequest({\n      resourceGroupName,\n      resourceProviderNamespace,\n      parentResourcePath,\n      resourceType,\n      resourceName,\n      apiVersion,\n      options\n    }, checkExistenceOperationSpec);\n  }\n  /**\n   * Deletes a resource.\n   * @param resourceGroupName The name of the resource group that contains the resource to delete. The\n   *                          name is case insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type.\n   * @param resourceName The name of the resource to delete.\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  async beginDelete(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceGroupName,\n        resourceProviderNamespace,\n        parentResourcePath,\n        resourceType,\n        resourceName,\n        apiVersion,\n        options\n      },\n      spec: deleteOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Deletes a resource.\n   * @param resourceGroupName The name of the resource group that contains the resource to delete. The\n   *                          name is case insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type.\n   * @param resourceName The name of the resource to delete.\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  async beginDeleteAndWait(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, options) {\n    const poller = await this.beginDelete(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Creates a resource.\n   * @param resourceGroupName The name of the resource group for the resource. The name is case\n   *                          insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type of the resource to create.\n   * @param resourceName The name of the resource to create.\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Parameters for creating or updating the resource.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdate(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceGroupName,\n        resourceProviderNamespace,\n        parentResourcePath,\n        resourceType,\n        resourceName,\n        apiVersion,\n        parameters,\n        options\n      },\n      spec: createOrUpdateOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Creates a resource.\n   * @param resourceGroupName The name of the resource group for the resource. The name is case\n   *                          insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type of the resource to create.\n   * @param resourceName The name of the resource to create.\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Parameters for creating or updating the resource.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAndWait(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, parameters, options) {\n    const poller = await this.beginCreateOrUpdate(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Updates a resource.\n   * @param resourceGroupName The name of the resource group for the resource. The name is case\n   *                          insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type of the resource to update.\n   * @param resourceName The name of the resource to update.\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Parameters for updating the resource.\n   * @param options The options parameters.\n   */\n  async beginUpdate(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceGroupName,\n        resourceProviderNamespace,\n        parentResourcePath,\n        resourceType,\n        resourceName,\n        apiVersion,\n        parameters,\n        options\n      },\n      spec: updateOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Updates a resource.\n   * @param resourceGroupName The name of the resource group for the resource. The name is case\n   *                          insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type of the resource to update.\n   * @param resourceName The name of the resource to update.\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Parameters for updating the resource.\n   * @param options The options parameters.\n   */\n  async beginUpdateAndWait(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, parameters, options) {\n    const poller = await this.beginUpdate(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Gets a resource.\n   * @param resourceGroupName The name of the resource group containing the resource to get. The name is\n   *                          case insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type of the resource.\n   * @param resourceName The name of the resource to get.\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  get(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, options) {\n    return this.client.sendOperationRequest({\n      resourceGroupName,\n      resourceProviderNamespace,\n      parentResourcePath,\n      resourceType,\n      resourceName,\n      apiVersion,\n      options\n    }, getOperationSpec);\n  }\n  /**\n   * Checks by ID whether a resource exists. This API currently works only for a limited set of Resource\n   * providers. In the event that a Resource provider does not implement this API, ARM will respond with\n   * a 405. The alternative then is to use the GET API to check for the existence of the resource.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  checkExistenceById(resourceId, apiVersion, options) {\n    return this.client.sendOperationRequest({\n      resourceId,\n      apiVersion,\n      options\n    }, checkExistenceByIdOperationSpec);\n  }\n  /**\n   * Deletes a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  async beginDeleteById(resourceId, apiVersion, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceId,\n        apiVersion,\n        options\n      },\n      spec: deleteByIdOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Deletes a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  async beginDeleteByIdAndWait(resourceId, apiVersion, options) {\n    const poller = await this.beginDeleteById(resourceId, apiVersion, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Create a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Create or update resource parameters.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateById(resourceId, apiVersion, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceId,\n        apiVersion,\n        parameters,\n        options\n      },\n      spec: createOrUpdateByIdOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Create a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Create or update resource parameters.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateByIdAndWait(resourceId, apiVersion, parameters, options) {\n    const poller = await this.beginCreateOrUpdateById(resourceId, apiVersion, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Updates a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Update resource parameters.\n   * @param options The options parameters.\n   */\n  async beginUpdateById(resourceId, apiVersion, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceId,\n        apiVersion,\n        parameters,\n        options\n      },\n      spec: updateByIdOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Updates a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Update resource parameters.\n   * @param options The options parameters.\n   */\n  async beginUpdateByIdAndWait(resourceId, apiVersion, parameters, options) {\n    const poller = await this.beginUpdateById(resourceId, apiVersion, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Gets a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  getById(resourceId, apiVersion, options) {\n    return this.client.sendOperationRequest({\n      resourceId,\n      apiVersion,\n      options\n    }, getByIdOperationSpec);\n  }\n  /**\n   * ListByResourceGroupNext\n   * @param resourceGroupName The resource group with the resources to get.\n   * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.\n   * @param options The options parameters.\n   */\n  _listByResourceGroupNext(resourceGroupName, nextLink, options) {\n    return this.client.sendOperationRequest({\n      resourceGroupName,\n      nextLink,\n      options\n    }, listByResourceGroupNextOperationSpec);\n  }\n  /**\n   * ListNext\n   * @param nextLink The nextLink from the previous successful call to the List method.\n   * @param options The options parameters.\n   */\n  _listNext(nextLink, options) {\n    return this.client.sendOperationRequest({\n      nextLink,\n      options\n    }, listNextOperationSpec);\n  }\n}\n// Operation Specifications\nconst serializer = coreClient.createSerializer(Mappers, /* isXml */false);\nconst listByResourceGroupOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/resources\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.ResourceListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top, Parameters.expand],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId, Parameters.resourceGroupName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst moveResourcesOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/moveResources\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters4,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId, Parameters.sourceResourceGroupName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst validateMoveResourcesOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/validateMoveResources\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters4,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId, Parameters.sourceResourceGroupName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst listOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resources\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.ResourceListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top, Parameters.expand],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst checkExistenceOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}\",\n  httpMethod: \"HEAD\",\n  responses: {\n    204: {},\n    404: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId, Parameters.resourceGroupName, Parameters.resourceProviderNamespace, Parameters.parentResourcePath, Parameters.resourceType, Parameters.resourceName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst deleteOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId, Parameters.resourceGroupName, Parameters.resourceProviderNamespace, Parameters.parentResourcePath, Parameters.resourceType, Parameters.resourceName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst createOrUpdateOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.GenericResource\n    },\n    201: {\n      bodyMapper: Mappers.GenericResource\n    },\n    202: {\n      bodyMapper: Mappers.GenericResource\n    },\n    204: {\n      bodyMapper: Mappers.GenericResource\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters5,\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId, Parameters.resourceGroupName, Parameters.resourceProviderNamespace, Parameters.parentResourcePath, Parameters.resourceType, Parameters.resourceName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst updateOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}\",\n  httpMethod: \"PATCH\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.GenericResource\n    },\n    201: {\n      bodyMapper: Mappers.GenericResource\n    },\n    202: {\n      bodyMapper: Mappers.GenericResource\n    },\n    204: {\n      bodyMapper: Mappers.GenericResource\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters5,\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId, Parameters.resourceGroupName, Parameters.resourceProviderNamespace, Parameters.parentResourcePath, Parameters.resourceType, Parameters.resourceName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst getOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.GenericResource\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId, Parameters.resourceGroupName, Parameters.resourceProviderNamespace, Parameters.parentResourcePath, Parameters.resourceType, Parameters.resourceName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst checkExistenceByIdOperationSpec = {\n  path: \"/{resourceId}\",\n  httpMethod: \"HEAD\",\n  responses: {\n    204: {},\n    404: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.resourceId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst deleteByIdOperationSpec = {\n  path: \"/{resourceId}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.resourceId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst createOrUpdateByIdOperationSpec = {\n  path: \"/{resourceId}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.GenericResource\n    },\n    201: {\n      bodyMapper: Mappers.GenericResource\n    },\n    202: {\n      bodyMapper: Mappers.GenericResource\n    },\n    204: {\n      bodyMapper: Mappers.GenericResource\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters5,\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.resourceId],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst updateByIdOperationSpec = {\n  path: \"/{resourceId}\",\n  httpMethod: \"PATCH\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.GenericResource\n    },\n    201: {\n      bodyMapper: Mappers.GenericResource\n    },\n    202: {\n      bodyMapper: Mappers.GenericResource\n    },\n    204: {\n      bodyMapper: Mappers.GenericResource\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters5,\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.resourceId],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst getByIdOperationSpec = {\n  path: \"/{resourceId}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.GenericResource\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.resourceId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listByResourceGroupNextOperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.ResourceListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.subscriptionId, Parameters.resourceGroupName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listNextOperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.ResourceListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept],\n  serializer\n};","map":{"version":3,"names":["setContinuationToken","coreClient","Mappers","Parameters","createHttpPoller","createLroSpec","ResourcesImpl","constructor","client","listByResourceGroup","resourceGroupName","options","iter","listByResourceGroupPagingAll","next","Symbol","asyncIterator","byPage","settings","maxPageSize","Error","listByResourceGroupPagingPage","result","continuationToken","__await","_listByResourceGroup","page","value","nextLink","_listByResourceGroupNext","_d","_e","__asyncValues","_f","_a","done","_c","__asyncDelegator","list","listPagingAll","listPagingPage","_list","_listNext","sendOperationRequest","listByResourceGroupOperationSpec","beginMoveResources","sourceResourceGroupName","parameters","directSendOperation","args","spec","sendOperationFn","currentRawResponse","undefined","providedCallback","onResponse","callback","rawResponse","flatResponse","updatedArgs","Object","assign","statusCode","status","body","parsedBody","headers","toJSON","lro","moveResourcesOperationSpec","poller","restoreFrom","resumeFrom","intervalInMs","updateIntervalInMs","poll","beginMoveResourcesAndWait","pollUntilDone","beginValidateMoveResources","validateMoveResourcesOperationSpec","beginValidateMoveResourcesAndWait","listOperationSpec","checkExistence","resourceProviderNamespace","parentResourcePath","resourceType","resourceName","apiVersion","checkExistenceOperationSpec","beginDelete","deleteOperationSpec","beginDeleteAndWait","beginCreateOrUpdate","createOrUpdateOperationSpec","beginCreateOrUpdateAndWait","beginUpdate","updateOperationSpec","beginUpdateAndWait","get","getOperationSpec","checkExistenceById","resourceId","checkExistenceByIdOperationSpec","beginDeleteById","deleteByIdOperationSpec","beginDeleteByIdAndWait","beginCreateOrUpdateById","createOrUpdateByIdOperationSpec","beginCreateOrUpdateByIdAndWait","beginUpdateById","updateByIdOperationSpec","beginUpdateByIdAndWait","getById","getByIdOperationSpec","listByResourceGroupNextOperationSpec","listNextOperationSpec","serializer","createSerializer","path","httpMethod","responses","bodyMapper","ResourceListResult","default","CloudError","queryParameters","filter","top","expand","urlParameters","$host","subscriptionId","headerParameters","accept","requestBody","parameters4","contentType","mediaType","apiVersion1","GenericResource","parameters5"],"sources":["/home/runner/work/Azure-Service-Deployment-Web/Azure-Service-Deployment-Web/node_modules/@azure/arm-resources/src/operations/resources.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport { PagedAsyncIterableIterator, PageSettings } from \"@azure/core-paging\";\nimport { setContinuationToken } from \"../pagingHelper.js\";\nimport { Resources } from \"../operationsInterfaces/index.js\";\nimport * as coreClient from \"@azure/core-client\";\nimport * as Mappers from \"../models/mappers.js\";\nimport * as Parameters from \"../models/parameters.js\";\nimport { ResourceManagementClient } from \"../resourceManagementClient.js\";\nimport {\n  SimplePollerLike,\n  OperationState,\n  createHttpPoller,\n} from \"@azure/core-lro\";\nimport { createLroSpec } from \"../lroImpl.js\";\nimport {\n  GenericResourceExpanded,\n  ResourcesListByResourceGroupNextOptionalParams,\n  ResourcesListByResourceGroupOptionalParams,\n  ResourcesListByResourceGroupResponse,\n  ResourcesListNextOptionalParams,\n  ResourcesListOptionalParams,\n  ResourcesListResponse,\n  ResourcesMoveInfo,\n  ResourcesMoveResourcesOptionalParams,\n  ResourcesValidateMoveResourcesOptionalParams,\n  ResourcesCheckExistenceOptionalParams,\n  ResourcesCheckExistenceResponse,\n  ResourcesDeleteOptionalParams,\n  GenericResource,\n  ResourcesCreateOrUpdateOptionalParams,\n  ResourcesCreateOrUpdateResponse,\n  ResourcesUpdateOptionalParams,\n  ResourcesUpdateResponse,\n  ResourcesGetOptionalParams,\n  ResourcesGetResponse,\n  ResourcesCheckExistenceByIdOptionalParams,\n  ResourcesCheckExistenceByIdResponse,\n  ResourcesDeleteByIdOptionalParams,\n  ResourcesCreateOrUpdateByIdOptionalParams,\n  ResourcesCreateOrUpdateByIdResponse,\n  ResourcesUpdateByIdOptionalParams,\n  ResourcesUpdateByIdResponse,\n  ResourcesGetByIdOptionalParams,\n  ResourcesGetByIdResponse,\n  ResourcesListByResourceGroupNextResponse,\n  ResourcesListNextResponse,\n} from \"../models/index.js\";\n\n/// <reference lib=\"esnext.asynciterable\" />\n/** Class containing Resources operations. */\nexport class ResourcesImpl implements Resources {\n  private readonly client: ResourceManagementClient;\n\n  /**\n   * Initialize a new instance of the class Resources class.\n   * @param client Reference to the service client\n   */\n  constructor(client: ResourceManagementClient) {\n    this.client = client;\n  }\n\n  /**\n   * Get all the resources for a resource group.\n   * @param resourceGroupName The resource group with the resources to get.\n   * @param options The options parameters.\n   */\n  public listByResourceGroup(\n    resourceGroupName: string,\n    options?: ResourcesListByResourceGroupOptionalParams,\n  ): PagedAsyncIterableIterator<GenericResourceExpanded> {\n    const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings?: PageSettings) => {\n        if (settings?.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listByResourceGroupPagingPage(\n          resourceGroupName,\n          options,\n          settings,\n        );\n      },\n    };\n  }\n\n  private async *listByResourceGroupPagingPage(\n    resourceGroupName: string,\n    options?: ResourcesListByResourceGroupOptionalParams,\n    settings?: PageSettings,\n  ): AsyncIterableIterator<GenericResourceExpanded[]> {\n    let result: ResourcesListByResourceGroupResponse;\n    let continuationToken = settings?.continuationToken;\n    if (!continuationToken) {\n      result = await this._listByResourceGroup(resourceGroupName, options);\n      let page = result.value || [];\n      continuationToken = result.nextLink;\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n    while (continuationToken) {\n      result = await this._listByResourceGroupNext(\n        resourceGroupName,\n        continuationToken,\n        options,\n      );\n      continuationToken = result.nextLink;\n      let page = result.value || [];\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n  }\n\n  private async *listByResourceGroupPagingAll(\n    resourceGroupName: string,\n    options?: ResourcesListByResourceGroupOptionalParams,\n  ): AsyncIterableIterator<GenericResourceExpanded> {\n    for await (const page of this.listByResourceGroupPagingPage(\n      resourceGroupName,\n      options,\n    )) {\n      yield* page;\n    }\n  }\n\n  /**\n   * Get all the resources in a subscription.\n   * @param options The options parameters.\n   */\n  public list(\n    options?: ResourcesListOptionalParams,\n  ): PagedAsyncIterableIterator<GenericResourceExpanded> {\n    const iter = this.listPagingAll(options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings?: PageSettings) => {\n        if (settings?.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listPagingPage(options, settings);\n      },\n    };\n  }\n\n  private async *listPagingPage(\n    options?: ResourcesListOptionalParams,\n    settings?: PageSettings,\n  ): AsyncIterableIterator<GenericResourceExpanded[]> {\n    let result: ResourcesListResponse;\n    let continuationToken = settings?.continuationToken;\n    if (!continuationToken) {\n      result = await this._list(options);\n      let page = result.value || [];\n      continuationToken = result.nextLink;\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n    while (continuationToken) {\n      result = await this._listNext(continuationToken, options);\n      continuationToken = result.nextLink;\n      let page = result.value || [];\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n  }\n\n  private async *listPagingAll(\n    options?: ResourcesListOptionalParams,\n  ): AsyncIterableIterator<GenericResourceExpanded> {\n    for await (const page of this.listPagingPage(options)) {\n      yield* page;\n    }\n  }\n\n  /**\n   * Get all the resources for a resource group.\n   * @param resourceGroupName The resource group with the resources to get.\n   * @param options The options parameters.\n   */\n  private _listByResourceGroup(\n    resourceGroupName: string,\n    options?: ResourcesListByResourceGroupOptionalParams,\n  ): Promise<ResourcesListByResourceGroupResponse> {\n    return this.client.sendOperationRequest(\n      { resourceGroupName, options },\n      listByResourceGroupOperationSpec,\n    );\n  }\n\n  /**\n   * The resources to be moved must be in the same source resource group in the source subscription being\n   * used. The target resource group may be in a different subscription. When moving resources, both the\n   * source group and the target group are locked for the duration of the operation. Write and delete\n   * operations are blocked on the groups until the move completes.\n   * @param sourceResourceGroupName The name of the resource group from the source subscription\n   *                                containing the resources to be moved.\n   * @param parameters Parameters for moving resources.\n   * @param options The options parameters.\n   */\n  async beginMoveResources(\n    sourceResourceGroupName: string,\n    parameters: ResourcesMoveInfo,\n    options?: ResourcesMoveResourcesOptionalParams,\n  ): Promise<SimplePollerLike<OperationState<void>, void>> {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<void> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { sourceResourceGroupName, parameters, options },\n      spec: moveResourcesOperationSpec,\n    });\n    const poller = await createHttpPoller<void, OperationState<void>>(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * The resources to be moved must be in the same source resource group in the source subscription being\n   * used. The target resource group may be in a different subscription. When moving resources, both the\n   * source group and the target group are locked for the duration of the operation. Write and delete\n   * operations are blocked on the groups until the move completes.\n   * @param sourceResourceGroupName The name of the resource group from the source subscription\n   *                                containing the resources to be moved.\n   * @param parameters Parameters for moving resources.\n   * @param options The options parameters.\n   */\n  async beginMoveResourcesAndWait(\n    sourceResourceGroupName: string,\n    parameters: ResourcesMoveInfo,\n    options?: ResourcesMoveResourcesOptionalParams,\n  ): Promise<void> {\n    const poller = await this.beginMoveResources(\n      sourceResourceGroupName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * This operation checks whether the specified resources can be moved to the target. The resources to\n   * be moved must be in the same source resource group in the source subscription being used. The target\n   * resource group may be in a different subscription. If validation succeeds, it returns HTTP response\n   * code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an\n   * error message. Retrieve the URL in the Location header value to check the result of the long-running\n   * operation.\n   * @param sourceResourceGroupName The name of the resource group from the source subscription\n   *                                containing the resources to be validated for move.\n   * @param parameters Parameters for moving resources.\n   * @param options The options parameters.\n   */\n  async beginValidateMoveResources(\n    sourceResourceGroupName: string,\n    parameters: ResourcesMoveInfo,\n    options?: ResourcesValidateMoveResourcesOptionalParams,\n  ): Promise<SimplePollerLike<OperationState<void>, void>> {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<void> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { sourceResourceGroupName, parameters, options },\n      spec: validateMoveResourcesOperationSpec,\n    });\n    const poller = await createHttpPoller<void, OperationState<void>>(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * This operation checks whether the specified resources can be moved to the target. The resources to\n   * be moved must be in the same source resource group in the source subscription being used. The target\n   * resource group may be in a different subscription. If validation succeeds, it returns HTTP response\n   * code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an\n   * error message. Retrieve the URL in the Location header value to check the result of the long-running\n   * operation.\n   * @param sourceResourceGroupName The name of the resource group from the source subscription\n   *                                containing the resources to be validated for move.\n   * @param parameters Parameters for moving resources.\n   * @param options The options parameters.\n   */\n  async beginValidateMoveResourcesAndWait(\n    sourceResourceGroupName: string,\n    parameters: ResourcesMoveInfo,\n    options?: ResourcesValidateMoveResourcesOptionalParams,\n  ): Promise<void> {\n    const poller = await this.beginValidateMoveResources(\n      sourceResourceGroupName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Get all the resources in a subscription.\n   * @param options The options parameters.\n   */\n  private _list(\n    options?: ResourcesListOptionalParams,\n  ): Promise<ResourcesListResponse> {\n    return this.client.sendOperationRequest({ options }, listOperationSpec);\n  }\n\n  /**\n   * Checks whether a resource exists.\n   * @param resourceGroupName The name of the resource group containing the resource to check. The name\n   *                          is case insensitive.\n   * @param resourceProviderNamespace The resource provider of the resource to check.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type.\n   * @param resourceName The name of the resource to check whether it exists.\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  checkExistence(\n    resourceGroupName: string,\n    resourceProviderNamespace: string,\n    parentResourcePath: string,\n    resourceType: string,\n    resourceName: string,\n    apiVersion: string,\n    options?: ResourcesCheckExistenceOptionalParams,\n  ): Promise<ResourcesCheckExistenceResponse> {\n    return this.client.sendOperationRequest(\n      {\n        resourceGroupName,\n        resourceProviderNamespace,\n        parentResourcePath,\n        resourceType,\n        resourceName,\n        apiVersion,\n        options,\n      },\n      checkExistenceOperationSpec,\n    );\n  }\n\n  /**\n   * Deletes a resource.\n   * @param resourceGroupName The name of the resource group that contains the resource to delete. The\n   *                          name is case insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type.\n   * @param resourceName The name of the resource to delete.\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  async beginDelete(\n    resourceGroupName: string,\n    resourceProviderNamespace: string,\n    parentResourcePath: string,\n    resourceType: string,\n    resourceName: string,\n    apiVersion: string,\n    options?: ResourcesDeleteOptionalParams,\n  ): Promise<SimplePollerLike<OperationState<void>, void>> {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<void> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceGroupName,\n        resourceProviderNamespace,\n        parentResourcePath,\n        resourceType,\n        resourceName,\n        apiVersion,\n        options,\n      },\n      spec: deleteOperationSpec,\n    });\n    const poller = await createHttpPoller<void, OperationState<void>>(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Deletes a resource.\n   * @param resourceGroupName The name of the resource group that contains the resource to delete. The\n   *                          name is case insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type.\n   * @param resourceName The name of the resource to delete.\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  async beginDeleteAndWait(\n    resourceGroupName: string,\n    resourceProviderNamespace: string,\n    parentResourcePath: string,\n    resourceType: string,\n    resourceName: string,\n    apiVersion: string,\n    options?: ResourcesDeleteOptionalParams,\n  ): Promise<void> {\n    const poller = await this.beginDelete(\n      resourceGroupName,\n      resourceProviderNamespace,\n      parentResourcePath,\n      resourceType,\n      resourceName,\n      apiVersion,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Creates a resource.\n   * @param resourceGroupName The name of the resource group for the resource. The name is case\n   *                          insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type of the resource to create.\n   * @param resourceName The name of the resource to create.\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Parameters for creating or updating the resource.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdate(\n    resourceGroupName: string,\n    resourceProviderNamespace: string,\n    parentResourcePath: string,\n    resourceType: string,\n    resourceName: string,\n    apiVersion: string,\n    parameters: GenericResource,\n    options?: ResourcesCreateOrUpdateOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<ResourcesCreateOrUpdateResponse>,\n      ResourcesCreateOrUpdateResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<ResourcesCreateOrUpdateResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceGroupName,\n        resourceProviderNamespace,\n        parentResourcePath,\n        resourceType,\n        resourceName,\n        apiVersion,\n        parameters,\n        options,\n      },\n      spec: createOrUpdateOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      ResourcesCreateOrUpdateResponse,\n      OperationState<ResourcesCreateOrUpdateResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Creates a resource.\n   * @param resourceGroupName The name of the resource group for the resource. The name is case\n   *                          insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type of the resource to create.\n   * @param resourceName The name of the resource to create.\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Parameters for creating or updating the resource.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAndWait(\n    resourceGroupName: string,\n    resourceProviderNamespace: string,\n    parentResourcePath: string,\n    resourceType: string,\n    resourceName: string,\n    apiVersion: string,\n    parameters: GenericResource,\n    options?: ResourcesCreateOrUpdateOptionalParams,\n  ): Promise<ResourcesCreateOrUpdateResponse> {\n    const poller = await this.beginCreateOrUpdate(\n      resourceGroupName,\n      resourceProviderNamespace,\n      parentResourcePath,\n      resourceType,\n      resourceName,\n      apiVersion,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Updates a resource.\n   * @param resourceGroupName The name of the resource group for the resource. The name is case\n   *                          insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type of the resource to update.\n   * @param resourceName The name of the resource to update.\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Parameters for updating the resource.\n   * @param options The options parameters.\n   */\n  async beginUpdate(\n    resourceGroupName: string,\n    resourceProviderNamespace: string,\n    parentResourcePath: string,\n    resourceType: string,\n    resourceName: string,\n    apiVersion: string,\n    parameters: GenericResource,\n    options?: ResourcesUpdateOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<ResourcesUpdateResponse>,\n      ResourcesUpdateResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<ResourcesUpdateResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceGroupName,\n        resourceProviderNamespace,\n        parentResourcePath,\n        resourceType,\n        resourceName,\n        apiVersion,\n        parameters,\n        options,\n      },\n      spec: updateOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      ResourcesUpdateResponse,\n      OperationState<ResourcesUpdateResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Updates a resource.\n   * @param resourceGroupName The name of the resource group for the resource. The name is case\n   *                          insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type of the resource to update.\n   * @param resourceName The name of the resource to update.\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Parameters for updating the resource.\n   * @param options The options parameters.\n   */\n  async beginUpdateAndWait(\n    resourceGroupName: string,\n    resourceProviderNamespace: string,\n    parentResourcePath: string,\n    resourceType: string,\n    resourceName: string,\n    apiVersion: string,\n    parameters: GenericResource,\n    options?: ResourcesUpdateOptionalParams,\n  ): Promise<ResourcesUpdateResponse> {\n    const poller = await this.beginUpdate(\n      resourceGroupName,\n      resourceProviderNamespace,\n      parentResourcePath,\n      resourceType,\n      resourceName,\n      apiVersion,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Gets a resource.\n   * @param resourceGroupName The name of the resource group containing the resource to get. The name is\n   *                          case insensitive.\n   * @param resourceProviderNamespace The namespace of the resource provider.\n   * @param parentResourcePath The parent resource identity.\n   * @param resourceType The resource type of the resource.\n   * @param resourceName The name of the resource to get.\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  get(\n    resourceGroupName: string,\n    resourceProviderNamespace: string,\n    parentResourcePath: string,\n    resourceType: string,\n    resourceName: string,\n    apiVersion: string,\n    options?: ResourcesGetOptionalParams,\n  ): Promise<ResourcesGetResponse> {\n    return this.client.sendOperationRequest(\n      {\n        resourceGroupName,\n        resourceProviderNamespace,\n        parentResourcePath,\n        resourceType,\n        resourceName,\n        apiVersion,\n        options,\n      },\n      getOperationSpec,\n    );\n  }\n\n  /**\n   * Checks by ID whether a resource exists. This API currently works only for a limited set of Resource\n   * providers. In the event that a Resource provider does not implement this API, ARM will respond with\n   * a 405. The alternative then is to use the GET API to check for the existence of the resource.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  checkExistenceById(\n    resourceId: string,\n    apiVersion: string,\n    options?: ResourcesCheckExistenceByIdOptionalParams,\n  ): Promise<ResourcesCheckExistenceByIdResponse> {\n    return this.client.sendOperationRequest(\n      { resourceId, apiVersion, options },\n      checkExistenceByIdOperationSpec,\n    );\n  }\n\n  /**\n   * Deletes a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  async beginDeleteById(\n    resourceId: string,\n    apiVersion: string,\n    options?: ResourcesDeleteByIdOptionalParams,\n  ): Promise<SimplePollerLike<OperationState<void>, void>> {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<void> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { resourceId, apiVersion, options },\n      spec: deleteByIdOperationSpec,\n    });\n    const poller = await createHttpPoller<void, OperationState<void>>(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Deletes a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  async beginDeleteByIdAndWait(\n    resourceId: string,\n    apiVersion: string,\n    options?: ResourcesDeleteByIdOptionalParams,\n  ): Promise<void> {\n    const poller = await this.beginDeleteById(resourceId, apiVersion, options);\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Create a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Create or update resource parameters.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateById(\n    resourceId: string,\n    apiVersion: string,\n    parameters: GenericResource,\n    options?: ResourcesCreateOrUpdateByIdOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<ResourcesCreateOrUpdateByIdResponse>,\n      ResourcesCreateOrUpdateByIdResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<ResourcesCreateOrUpdateByIdResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { resourceId, apiVersion, parameters, options },\n      spec: createOrUpdateByIdOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      ResourcesCreateOrUpdateByIdResponse,\n      OperationState<ResourcesCreateOrUpdateByIdResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Create a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Create or update resource parameters.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateByIdAndWait(\n    resourceId: string,\n    apiVersion: string,\n    parameters: GenericResource,\n    options?: ResourcesCreateOrUpdateByIdOptionalParams,\n  ): Promise<ResourcesCreateOrUpdateByIdResponse> {\n    const poller = await this.beginCreateOrUpdateById(\n      resourceId,\n      apiVersion,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Updates a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Update resource parameters.\n   * @param options The options parameters.\n   */\n  async beginUpdateById(\n    resourceId: string,\n    apiVersion: string,\n    parameters: GenericResource,\n    options?: ResourcesUpdateByIdOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<ResourcesUpdateByIdResponse>,\n      ResourcesUpdateByIdResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<ResourcesUpdateByIdResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { resourceId, apiVersion, parameters, options },\n      spec: updateByIdOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      ResourcesUpdateByIdResponse,\n      OperationState<ResourcesUpdateByIdResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Updates a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param parameters Update resource parameters.\n   * @param options The options parameters.\n   */\n  async beginUpdateByIdAndWait(\n    resourceId: string,\n    apiVersion: string,\n    parameters: GenericResource,\n    options?: ResourcesUpdateByIdOptionalParams,\n  ): Promise<ResourcesUpdateByIdResponse> {\n    const poller = await this.beginUpdateById(\n      resourceId,\n      apiVersion,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Gets a resource by ID.\n   * @param resourceId The fully qualified ID of the resource, including the resource name and resource\n   *                   type. Use the format,\n   *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}\n   * @param apiVersion The API version to use for the operation.\n   * @param options The options parameters.\n   */\n  getById(\n    resourceId: string,\n    apiVersion: string,\n    options?: ResourcesGetByIdOptionalParams,\n  ): Promise<ResourcesGetByIdResponse> {\n    return this.client.sendOperationRequest(\n      { resourceId, apiVersion, options },\n      getByIdOperationSpec,\n    );\n  }\n\n  /**\n   * ListByResourceGroupNext\n   * @param resourceGroupName The resource group with the resources to get.\n   * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.\n   * @param options The options parameters.\n   */\n  private _listByResourceGroupNext(\n    resourceGroupName: string,\n    nextLink: string,\n    options?: ResourcesListByResourceGroupNextOptionalParams,\n  ): Promise<ResourcesListByResourceGroupNextResponse> {\n    return this.client.sendOperationRequest(\n      { resourceGroupName, nextLink, options },\n      listByResourceGroupNextOperationSpec,\n    );\n  }\n\n  /**\n   * ListNext\n   * @param nextLink The nextLink from the previous successful call to the List method.\n   * @param options The options parameters.\n   */\n  private _listNext(\n    nextLink: string,\n    options?: ResourcesListNextOptionalParams,\n  ): Promise<ResourcesListNextResponse> {\n    return this.client.sendOperationRequest(\n      { nextLink, options },\n      listNextOperationSpec,\n    );\n  }\n}\n// Operation Specifications\nconst serializer = coreClient.createSerializer(Mappers, /* isXml */ false);\n\nconst listByResourceGroupOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/resources\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.ResourceListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [\n    Parameters.apiVersion,\n    Parameters.filter,\n    Parameters.top,\n    Parameters.expand,\n  ],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst moveResourcesOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/moveResources\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters4,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.subscriptionId,\n    Parameters.sourceResourceGroupName,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst validateMoveResourcesOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/validateMoveResources\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters4,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.subscriptionId,\n    Parameters.sourceResourceGroupName,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst listOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resources\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.ResourceListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [\n    Parameters.apiVersion,\n    Parameters.filter,\n    Parameters.top,\n    Parameters.expand,\n  ],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst checkExistenceOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}\",\n  httpMethod: \"HEAD\",\n  responses: {\n    204: {},\n    404: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n    Parameters.resourceProviderNamespace,\n    Parameters.parentResourcePath,\n    Parameters.resourceType,\n    Parameters.resourceName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst deleteOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n    Parameters.resourceProviderNamespace,\n    Parameters.parentResourcePath,\n    Parameters.resourceType,\n    Parameters.resourceName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst createOrUpdateOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    201: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    202: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    204: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters5,\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n    Parameters.resourceProviderNamespace,\n    Parameters.parentResourcePath,\n    Parameters.resourceType,\n    Parameters.resourceName,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst updateOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}\",\n  httpMethod: \"PATCH\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    201: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    202: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    204: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters5,\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n    Parameters.resourceProviderNamespace,\n    Parameters.parentResourcePath,\n    Parameters.resourceType,\n    Parameters.resourceName,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst getOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n    Parameters.resourceProviderNamespace,\n    Parameters.parentResourcePath,\n    Parameters.resourceType,\n    Parameters.resourceName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst checkExistenceByIdOperationSpec: coreClient.OperationSpec = {\n  path: \"/{resourceId}\",\n  httpMethod: \"HEAD\",\n  responses: {\n    204: {},\n    404: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.resourceId],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst deleteByIdOperationSpec: coreClient.OperationSpec = {\n  path: \"/{resourceId}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.resourceId],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst createOrUpdateByIdOperationSpec: coreClient.OperationSpec = {\n  path: \"/{resourceId}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    201: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    202: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    204: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters5,\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.resourceId],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst updateByIdOperationSpec: coreClient.OperationSpec = {\n  path: \"/{resourceId}\",\n  httpMethod: \"PATCH\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    201: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    202: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    204: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters5,\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.resourceId],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst getByIdOperationSpec: coreClient.OperationSpec = {\n  path: \"/{resourceId}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.GenericResource,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion1],\n  urlParameters: [Parameters.$host, Parameters.resourceId],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst listByResourceGroupNextOperationSpec: coreClient.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.ResourceListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  urlParameters: [\n    Parameters.$host,\n    Parameters.nextLink,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst listNextOperationSpec: coreClient.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.ResourceListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  urlParameters: [\n    Parameters.$host,\n    Parameters.nextLink,\n    Parameters.subscriptionId,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}