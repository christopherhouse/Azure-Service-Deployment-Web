{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { XML_CHARKEY } from \"./interfaces.js\";\nimport { RestError } from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\nexport const deserializationPolicyName = \"deserializationPolicy\";\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\nexport function deserializationPolicy() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _a, _b, _c, _d, _e, _f, _g;\n  const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;\n  const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;\n  const parseXML = options.parseXML;\n  const serializerOptions = options.serializerOptions;\n  const updatedOptions = {\n    xml: {\n      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : \"\",\n      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,\n      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY\n    }\n  };\n  return {\n    name: deserializationPolicyName,\n    async sendRequest(request, next) {\n      const response = await next(request);\n      return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);\n    }\n  };\n}\nfunction getOperationResponseMap(parsedResponse) {\n  let result;\n  const request = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n  if (operationSpec) {\n    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {\n      result = operationSpec.responses[parsedResponse.status];\n    } else {\n      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);\n    }\n  }\n  return result;\n}\nfunction shouldDeserializeResponse(parsedResponse) {\n  const request = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;\n  let result;\n  if (shouldDeserialize === undefined) {\n    result = true;\n  } else if (typeof shouldDeserialize === \"boolean\") {\n    result = shouldDeserialize;\n  } else {\n    result = shouldDeserialize(parsedResponse);\n  }\n  return result;\n}\nasync function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {\n  const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);\n  if (!shouldDeserializeResponse(parsedResponse)) {\n    return parsedResponse;\n  }\n  const operationInfo = getOperationRequestInfo(parsedResponse.request);\n  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n  if (!operationSpec || !operationSpec.responses) {\n    return parsedResponse;\n  }\n  const responseSpec = getOperationResponseMap(parsedResponse);\n  const {\n    error,\n    shouldReturnResponse\n  } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);\n  if (error) {\n    throw error;\n  } else if (shouldReturnResponse) {\n    return parsedResponse;\n  }\n  // An operation response spec does exist for current status code, so\n  // use it to deserialize the response.\n  if (responseSpec) {\n    if (responseSpec.bodyMapper) {\n      let valueToDeserialize = parsedResponse.parsedBody;\n      if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n        valueToDeserialize = typeof valueToDeserialize === \"object\" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];\n      }\n      try {\n        parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\", options);\n      } catch (deserializeError) {\n        const restError = new RestError(\"Error \".concat(deserializeError, \" occurred in deserializing the responseBody - \").concat(parsedResponse.bodyAsText), {\n          statusCode: parsedResponse.status,\n          request: parsedResponse.request,\n          response: parsedResponse\n        });\n        throw restError;\n      }\n    } else if (operationSpec.httpMethod === \"HEAD\") {\n      // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n      parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n    }\n    if (responseSpec.headersMapper) {\n      parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\", {\n        xml: {},\n        ignoreUnknownProperties: true\n      });\n    }\n  }\n  return parsedResponse;\n}\nfunction isOperationSpecEmpty(operationSpec) {\n  const expectedStatusCodes = Object.keys(operationSpec.responses);\n  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\";\n}\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {\n  var _a, _b, _c, _d, _e;\n  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;\n  if (isExpectedStatusCode) {\n    if (responseSpec) {\n      if (!responseSpec.isError) {\n        return {\n          error: null,\n          shouldReturnResponse: false\n        };\n      }\n    } else {\n      return {\n        error: null,\n        shouldReturnResponse: false\n      };\n    }\n  }\n  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n  const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) ? \"Unexpected status code: \".concat(parsedResponse.status) : parsedResponse.bodyAsText;\n  const error = new RestError(initialErrorMessage, {\n    statusCode: parsedResponse.status,\n    request: parsedResponse.request,\n    response: parsedResponse\n  });\n  // If the item failed but there's no error spec or default spec to deserialize the error,\n  // and the parsed body doesn't look like an error object,\n  // we should fail so we just throw the parsed response\n  if (!errorResponseSpec && !(((_c = (_b = parsedResponse.parsedBody) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.code) && ((_e = (_d = parsedResponse.parsedBody) === null || _d === void 0 ? void 0 : _d.error) === null || _e === void 0 ? void 0 : _e.message))) {\n    throw error;\n  }\n  const defaultBodyMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.bodyMapper;\n  const defaultHeadersMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.headersMapper;\n  try {\n    // If error response has a body, try to deserialize it using default body mapper.\n    // Then try to extract error code & message from it\n    if (parsedResponse.parsedBody) {\n      const parsedBody = parsedResponse.parsedBody;\n      let deserializedError;\n      if (defaultBodyMapper) {\n        let valueToDeserialize = parsedBody;\n        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = [];\n          const elementName = defaultBodyMapper.xmlElementName;\n          if (typeof parsedBody === \"object\" && elementName) {\n            valueToDeserialize = parsedBody[elementName];\n          }\n        }\n        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\", options);\n      }\n      const internalError = parsedBody.error || deserializedError || parsedBody;\n      error.code = internalError.code;\n      if (internalError.message) {\n        error.message = internalError.message;\n      }\n      if (defaultBodyMapper) {\n        error.response.parsedBody = deserializedError;\n      }\n    }\n    // If error response has headers, try to deserialize it using default header mapper\n    if (parsedResponse.headers && defaultHeadersMapper) {\n      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n    }\n  } catch (defaultError) {\n    error.message = \"Error \\\"\".concat(defaultError.message, \"\\\" occurred in deserializing the responseBody - \\\"\").concat(parsedResponse.bodyAsText, \"\\\" for the default response.\");\n  }\n  return {\n    error,\n    shouldReturnResponse: false\n  };\n}\nasync function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {\n  var _a;\n  if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) && operationResponse.bodyAsText) {\n    const text = operationResponse.bodyAsText;\n    const contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n    const contentComponents = !contentType ? [] : contentType.split(\";\").map(component => component.toLowerCase());\n    try {\n      if (contentComponents.length === 0 || contentComponents.some(component => jsonContentTypes.indexOf(component) !== -1)) {\n        operationResponse.parsedBody = JSON.parse(text);\n        return operationResponse;\n      } else if (contentComponents.some(component => xmlContentTypes.indexOf(component) !== -1)) {\n        if (!parseXML) {\n          throw new Error(\"Parsing XML not supported.\");\n        }\n        const body = await parseXML(text, opts.xml);\n        operationResponse.parsedBody = body;\n        return operationResponse;\n      }\n    } catch (err) {\n      const msg = \"Error \\\"\".concat(err, \"\\\" occurred while parsing the response body - \").concat(operationResponse.bodyAsText, \".\");\n      const errCode = err.code || RestError.PARSE_ERROR;\n      const e = new RestError(msg, {\n        code: errCode,\n        statusCode: operationResponse.status,\n        request: operationResponse.request,\n        response: operationResponse\n      });\n      throw e;\n    }\n  }\n  return operationResponse;\n}","map":{"version":3,"names":["XML_CHARKEY","RestError","MapperTypeNames","getOperationRequestInfo","defaultJsonContentTypes","defaultXmlContentTypes","deserializationPolicyName","deserializationPolicy","options","arguments","length","undefined","jsonContentTypes","_b","_a","expectedContentTypes","json","xmlContentTypes","_d","_c","xml","parseXML","serializerOptions","updatedOptions","rootName","_e","includeRoot","_f","xmlCharKey","_g","name","sendRequest","request","next","response","deserializeResponseBody","getOperationResponseMap","parsedResponse","result","operationInfo","operationSpec","operationResponseGetter","responses","status","shouldDeserializeResponse","shouldDeserialize","parse","responseSpec","error","shouldReturnResponse","handleErrorResponse","bodyMapper","valueToDeserialize","parsedBody","isXML","type","Sequence","xmlElementName","serializer","deserialize","deserializeError","restError","concat","bodyAsText","statusCode","httpMethod","headersMapper","parsedHeaders","headers","toJSON","ignoreUnknownProperties","isOperationSpecEmpty","expectedStatusCodes","Object","keys","isSuccessByStatus","isExpectedStatusCode","isError","errorResponseSpec","default","initialErrorMessage","streamResponseStatusCodes","has","code","message","defaultBodyMapper","defaultHeadersMapper","deserializedError","elementName","internalError","defaultError","operationResponse","opts","text","contentType","get","contentComponents","split","map","component","toLowerCase","some","indexOf","JSON","Error","body","err","msg","errCode","PARSE_ERROR","e"],"sources":["/home/runner/work/Azure-Service-Deployment-Web/Azure-Service-Deployment-Web/node_modules/@azure/core-client/src/deserializationPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  FullOperationResponse,\n  OperationRequest,\n  OperationResponseMap,\n  OperationSpec,\n  RequiredSerializerOptions,\n  SerializerOptions,\n  XmlOptions,\n} from \"./interfaces.js\";\nimport { XML_CHARKEY } from \"./interfaces.js\";\nimport type {\n  PipelinePolicy,\n  PipelineRequest,\n  PipelineResponse,\n  SendRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { RestError } from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\n\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\nexport const deserializationPolicyName = \"deserializationPolicy\";\n\n/**\n * Options to configure API response deserialization.\n */\nexport interface DeserializationPolicyOptions {\n  /**\n   * Configures the expected content types for the deserialization of\n   * JSON and XML response bodies.\n   */\n  expectedContentTypes?: DeserializationContentTypes;\n\n  /**\n   * A function that is able to parse XML. Required for XML support.\n   */\n  parseXML?: (str: string, opts?: XmlOptions) => Promise<any>;\n\n  /**\n   * Configures behavior of xml parser and builder.\n   */\n  serializerOptions?: SerializerOptions;\n}\n\n/**\n * The content-types that will indicate that an operation response should be deserialized in a\n * particular way.\n */\nexport interface DeserializationContentTypes {\n  /**\n   * The content-types that indicate that an operation response should be deserialized as JSON.\n   * Defaults to [ \"application/json\", \"text/json\" ].\n   */\n  json?: string[];\n\n  /**\n   * The content-types that indicate that an operation response should be deserialized as XML.\n   * Defaults to [ \"application/xml\", \"application/atom+xml\" ].\n   */\n  xml?: string[];\n}\n\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\nexport function deserializationPolicy(options: DeserializationPolicyOptions = {}): PipelinePolicy {\n  const jsonContentTypes = options.expectedContentTypes?.json ?? defaultJsonContentTypes;\n  const xmlContentTypes = options.expectedContentTypes?.xml ?? defaultXmlContentTypes;\n  const parseXML = options.parseXML;\n  const serializerOptions = options.serializerOptions;\n  const updatedOptions: RequiredSerializerOptions = {\n    xml: {\n      rootName: serializerOptions?.xml.rootName ?? \"\",\n      includeRoot: serializerOptions?.xml.includeRoot ?? false,\n      xmlCharKey: serializerOptions?.xml.xmlCharKey ?? XML_CHARKEY,\n    },\n  };\n\n  return {\n    name: deserializationPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const response = await next(request);\n      return deserializeResponseBody(\n        jsonContentTypes,\n        xmlContentTypes,\n        response,\n        updatedOptions,\n        parseXML,\n      );\n    },\n  };\n}\n\nfunction getOperationResponseMap(\n  parsedResponse: PipelineResponse,\n): undefined | OperationResponseMap {\n  let result: OperationResponseMap | undefined;\n  const request: OperationRequest = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const operationSpec = operationInfo?.operationSpec;\n  if (operationSpec) {\n    if (!operationInfo?.operationResponseGetter) {\n      result = operationSpec.responses[parsedResponse.status];\n    } else {\n      result = operationInfo?.operationResponseGetter(operationSpec, parsedResponse);\n    }\n  }\n  return result;\n}\n\nfunction shouldDeserializeResponse(parsedResponse: PipelineResponse): boolean {\n  const request: OperationRequest = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const shouldDeserialize = operationInfo?.shouldDeserialize;\n  let result: boolean;\n  if (shouldDeserialize === undefined) {\n    result = true;\n  } else if (typeof shouldDeserialize === \"boolean\") {\n    result = shouldDeserialize;\n  } else {\n    result = shouldDeserialize(parsedResponse);\n  }\n  return result;\n}\n\nasync function deserializeResponseBody(\n  jsonContentTypes: string[],\n  xmlContentTypes: string[],\n  response: PipelineResponse,\n  options: RequiredSerializerOptions,\n  parseXML?: (str: string, opts?: XmlOptions) => Promise<any>,\n): Promise<PipelineResponse> {\n  const parsedResponse = await parse(\n    jsonContentTypes,\n    xmlContentTypes,\n    response,\n    options,\n    parseXML,\n  );\n  if (!shouldDeserializeResponse(parsedResponse)) {\n    return parsedResponse;\n  }\n\n  const operationInfo = getOperationRequestInfo(parsedResponse.request);\n  const operationSpec = operationInfo?.operationSpec;\n  if (!operationSpec || !operationSpec.responses) {\n    return parsedResponse;\n  }\n\n  const responseSpec = getOperationResponseMap(parsedResponse);\n  const { error, shouldReturnResponse } = handleErrorResponse(\n    parsedResponse,\n    operationSpec,\n    responseSpec,\n    options,\n  );\n  if (error) {\n    throw error;\n  } else if (shouldReturnResponse) {\n    return parsedResponse;\n  }\n\n  // An operation response spec does exist for current status code, so\n  // use it to deserialize the response.\n  if (responseSpec) {\n    if (responseSpec.bodyMapper) {\n      let valueToDeserialize: any = parsedResponse.parsedBody;\n      if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n        valueToDeserialize =\n          typeof valueToDeserialize === \"object\"\n            ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName!]\n            : [];\n      }\n      try {\n        parsedResponse.parsedBody = operationSpec.serializer.deserialize(\n          responseSpec.bodyMapper,\n          valueToDeserialize,\n          \"operationRes.parsedBody\",\n          options,\n        );\n      } catch (deserializeError: any) {\n        const restError = new RestError(\n          `Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`,\n          {\n            statusCode: parsedResponse.status,\n            request: parsedResponse.request,\n            response: parsedResponse,\n          },\n        );\n        throw restError;\n      }\n    } else if (operationSpec.httpMethod === \"HEAD\") {\n      // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n      parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n    }\n\n    if (responseSpec.headersMapper) {\n      parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(\n        responseSpec.headersMapper,\n        parsedResponse.headers.toJSON(),\n        \"operationRes.parsedHeaders\",\n        { xml: {}, ignoreUnknownProperties: true },\n      );\n    }\n  }\n\n  return parsedResponse;\n}\n\nfunction isOperationSpecEmpty(operationSpec: OperationSpec): boolean {\n  const expectedStatusCodes = Object.keys(operationSpec.responses);\n  return (\n    expectedStatusCodes.length === 0 ||\n    (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\")\n  );\n}\n\nfunction handleErrorResponse(\n  parsedResponse: FullOperationResponse,\n  operationSpec: OperationSpec,\n  responseSpec: OperationResponseMap | undefined,\n  options: RequiredSerializerOptions,\n): { error: RestError | null; shouldReturnResponse: boolean } {\n  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n  const isExpectedStatusCode: boolean = isOperationSpecEmpty(operationSpec)\n    ? isSuccessByStatus\n    : !!responseSpec;\n\n  if (isExpectedStatusCode) {\n    if (responseSpec) {\n      if (!responseSpec.isError) {\n        return { error: null, shouldReturnResponse: false };\n      }\n    } else {\n      return { error: null, shouldReturnResponse: false };\n    }\n  }\n\n  const errorResponseSpec = responseSpec ?? operationSpec.responses.default;\n\n  const initialErrorMessage = parsedResponse.request.streamResponseStatusCodes?.has(\n    parsedResponse.status,\n  )\n    ? `Unexpected status code: ${parsedResponse.status}`\n    : (parsedResponse.bodyAsText as string);\n\n  const error = new RestError(initialErrorMessage, {\n    statusCode: parsedResponse.status,\n    request: parsedResponse.request,\n    response: parsedResponse,\n  });\n\n  // If the item failed but there's no error spec or default spec to deserialize the error,\n  // and the parsed body doesn't look like an error object,\n  // we should fail so we just throw the parsed response\n  if (\n    !errorResponseSpec &&\n    !(parsedResponse.parsedBody?.error?.code && parsedResponse.parsedBody?.error?.message)\n  ) {\n    throw error;\n  }\n\n  const defaultBodyMapper = errorResponseSpec?.bodyMapper;\n  const defaultHeadersMapper = errorResponseSpec?.headersMapper;\n\n  try {\n    // If error response has a body, try to deserialize it using default body mapper.\n    // Then try to extract error code & message from it\n    if (parsedResponse.parsedBody) {\n      const parsedBody = parsedResponse.parsedBody;\n      let deserializedError;\n\n      if (defaultBodyMapper) {\n        let valueToDeserialize: any = parsedBody;\n        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = [];\n          const elementName = defaultBodyMapper.xmlElementName;\n          if (typeof parsedBody === \"object\" && elementName) {\n            valueToDeserialize = parsedBody[elementName];\n          }\n        }\n        deserializedError = operationSpec.serializer.deserialize(\n          defaultBodyMapper,\n          valueToDeserialize,\n          \"error.response.parsedBody\",\n          options,\n        );\n      }\n\n      const internalError: any = parsedBody.error || deserializedError || parsedBody;\n      error.code = internalError.code;\n      if (internalError.message) {\n        error.message = internalError.message;\n      }\n\n      if (defaultBodyMapper) {\n        (error.response! as FullOperationResponse).parsedBody = deserializedError;\n      }\n    }\n\n    // If error response has headers, try to deserialize it using default header mapper\n    if (parsedResponse.headers && defaultHeadersMapper) {\n      (error.response! as FullOperationResponse).parsedHeaders =\n        operationSpec.serializer.deserialize(\n          defaultHeadersMapper,\n          parsedResponse.headers.toJSON(),\n          \"operationRes.parsedHeaders\",\n        );\n    }\n  } catch (defaultError: any) {\n    error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n  }\n\n  return { error, shouldReturnResponse: false };\n}\n\nasync function parse(\n  jsonContentTypes: string[],\n  xmlContentTypes: string[],\n  operationResponse: FullOperationResponse,\n  opts: RequiredSerializerOptions,\n  parseXML?: (str: string, opts?: XmlOptions) => Promise<any>,\n): Promise<FullOperationResponse> {\n  if (\n    !operationResponse.request.streamResponseStatusCodes?.has(operationResponse.status) &&\n    operationResponse.bodyAsText\n  ) {\n    const text = operationResponse.bodyAsText;\n    const contentType: string = operationResponse.headers.get(\"Content-Type\") || \"\";\n    const contentComponents: string[] = !contentType\n      ? []\n      : contentType.split(\";\").map((component) => component.toLowerCase());\n\n    try {\n      if (\n        contentComponents.length === 0 ||\n        contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)\n      ) {\n        operationResponse.parsedBody = JSON.parse(text);\n        return operationResponse;\n      } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {\n        if (!parseXML) {\n          throw new Error(\"Parsing XML not supported.\");\n        }\n        const body = await parseXML(text, opts.xml);\n        operationResponse.parsedBody = body;\n        return operationResponse;\n      }\n    } catch (err: any) {\n      const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n      const errCode = err.code || RestError.PARSE_ERROR;\n      const e = new RestError(msg, {\n        code: errCode,\n        statusCode: operationResponse.status,\n        request: operationResponse.request,\n        response: operationResponse,\n      });\n      throw e;\n    }\n  }\n\n  return operationResponse;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}