{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport debug from \"./debug.js\";\nconst TYPESPEC_RUNTIME_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\nconst levelMap = {\n  verbose: 400,\n  info: 300,\n  warning: 200,\n  error: 100\n};\nfunction patchLogMethod(parent, child) {\n  child.log = function () {\n    parent.log(...arguments);\n  };\n}\nfunction isTypeSpecRuntimeLogLevel(level) {\n  return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);\n}\n/**\n * Creates a logger context base on the provided options.\n * @param options - The options for creating a logger context.\n * @returns The logger context.\n */\nexport function createLoggerContext(options) {\n  const registeredLoggers = new Set();\n  const logLevelFromEnv = typeof process !== \"undefined\" && process.env && process.env[options.logLevelEnvVarName] || undefined;\n  let logLevel;\n  const clientLogger = debug(options.namespace);\n  clientLogger.log = function () {\n    debug.log(...arguments);\n  };\n  function contextSetLogLevel(level) {\n    if (level && !isTypeSpecRuntimeLogLevel(level)) {\n      throw new Error(\"Unknown log level '\".concat(level, \"'. Acceptable values: \").concat(TYPESPEC_RUNTIME_LOG_LEVELS.join(\",\")));\n    }\n    logLevel = level;\n    const enabledNamespaces = [];\n    for (const logger of registeredLoggers) {\n      if (shouldEnable(logger)) {\n        enabledNamespaces.push(logger.namespace);\n      }\n    }\n    debug.enable(enabledNamespaces.join(\",\"));\n  }\n  if (logLevelFromEnv) {\n    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n    if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {\n      contextSetLogLevel(logLevelFromEnv);\n    } else {\n      console.error(\"\".concat(options.logLevelEnvVarName, \" set to unknown log level '\").concat(logLevelFromEnv, \"'; logging is not enabled. Acceptable values: \").concat(TYPESPEC_RUNTIME_LOG_LEVELS.join(\", \"), \".\"));\n    }\n  }\n  function shouldEnable(logger) {\n    return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);\n  }\n  function createLogger(parent, level) {\n    const logger = Object.assign(parent.extend(level), {\n      level\n    });\n    patchLogMethod(parent, logger);\n    if (shouldEnable(logger)) {\n      const enabledNamespaces = debug.disable();\n      debug.enable(enabledNamespaces + \",\" + logger.namespace);\n    }\n    registeredLoggers.add(logger);\n    return logger;\n  }\n  function contextGetLogLevel() {\n    return logLevel;\n  }\n  function contextCreateClientLogger(namespace) {\n    const clientRootLogger = clientLogger.extend(namespace);\n    patchLogMethod(clientLogger, clientRootLogger);\n    return {\n      error: createLogger(clientRootLogger, \"error\"),\n      warning: createLogger(clientRootLogger, \"warning\"),\n      info: createLogger(clientRootLogger, \"info\"),\n      verbose: createLogger(clientRootLogger, \"verbose\")\n    };\n  }\n  return {\n    setLogLevel: contextSetLogLevel,\n    getLogLevel: contextGetLogLevel,\n    createClientLogger: contextCreateClientLogger,\n    logger: clientLogger\n  };\n}\nconst context = createLoggerContext({\n  logLevelEnvVarName: \"TYPESPEC_RUNTIME_LOG_LEVEL\",\n  namespace: \"typeSpecRuntime\"\n});\n/**\n * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n * @param level - The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const TypeSpecRuntimeLogger = context.logger;\n/**\n * Retrieves the currently specified log level.\n */\nexport function setLogLevel(logLevel) {\n  context.setLogLevel(logLevel);\n}\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel() {\n  return context.getLogLevel();\n}\n/**\n * Creates a logger for use by the SDKs that inherits from `TypeSpecRuntimeLogger`.\n * @param namespace - The name of the SDK package.\n * @hidden\n */\nexport function createClientLogger(namespace) {\n  return context.createClientLogger(namespace);\n}","map":{"version":3,"names":["debug","TYPESPEC_RUNTIME_LOG_LEVELS","levelMap","verbose","info","warning","error","patchLogMethod","parent","child","log","arguments","isTypeSpecRuntimeLogLevel","level","includes","createLoggerContext","options","registeredLoggers","Set","logLevelFromEnv","process","env","logLevelEnvVarName","undefined","logLevel","clientLogger","namespace","contextSetLogLevel","Error","concat","join","enabledNamespaces","logger","shouldEnable","push","enable","console","Boolean","createLogger","Object","assign","extend","disable","add","contextGetLogLevel","contextCreateClientLogger","clientRootLogger","setLogLevel","getLogLevel","createClientLogger","context","TypeSpecRuntimeLogger"],"sources":["/home/runner/work/Azure-Service-Deployment-Web/Azure-Service-Deployment-Web/node_modules/@typespec/ts-http-runtime/src/logger/logger.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport debug from \"./debug.js\";\n\nimport type { Debugger } from \"./debug.js\";\nexport type { Debugger };\n\n/**\n * The log levels supported by the logger.\n * The log levels in order of most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport type TypeSpecRuntimeLogLevel = \"verbose\" | \"info\" | \"warning\" | \"error\";\n\n/**\n * A TypeSpecRuntimeClientLogger is a function that can log to an appropriate severity level.\n */\nexport type TypeSpecRuntimeClientLogger = Debugger;\n\n/**\n * Defines the methods available on the SDK-facing logger.\n */\nexport interface TypeSpecRuntimeLogger {\n  /**\n   * Used for failures the program is unlikely to recover from,\n   * such as Out of Memory.\n   */\n  error: Debugger;\n  /**\n   * Used when a function fails to perform its intended task.\n   * Usually this means the function will throw an exception.\n   * Not used for self-healing events (e.g. automatic retry)\n   */\n  warning: Debugger;\n  /**\n   * Used when a function operates normally.\n   */\n  info: Debugger;\n  /**\n   * Used for detailed troubleshooting scenarios. This is\n   * intended for use by developers / system administrators\n   * for diagnosing specific failures.\n   */\n  verbose: Debugger;\n}\n\n/**\n * todo doc\n */\nexport interface LoggerContext {\n  /**\n   * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n   * @param level - The log level to enable for logging.\n   * Options from most verbose to least verbose are:\n   * - verbose\n   * - info\n   * - warning\n   * - error\n   */\n  setLogLevel(logLevel?: TypeSpecRuntimeLogLevel): void;\n\n  /**\n   * Retrieves the currently specified log level.\n   */\n  getLogLevel(): TypeSpecRuntimeLogLevel | undefined;\n\n  /**\n   * Creates a logger for use by the SDKs that inherits from `TypeSpecRuntimeLogger`.\n   * @param namespace - The name of the SDK package.\n   * @hidden\n   */\n  createClientLogger(namespace: string): TypeSpecRuntimeLogger;\n\n  /**\n   * The TypeSpecRuntimeClientLogger provides a mechanism for overriding where logs are output to.\n   * By default, logs are sent to stderr.\n   * Override the `log` method to redirect logs to another location.\n   */\n  logger: TypeSpecRuntimeClientLogger;\n}\n\n/**\n * Option for creating a TypeSpecRuntimeLoggerContext.\n */\nexport interface CreateLoggerContextOptions {\n  /**\n   * The name of the environment variable to check for the log level.\n   */\n  logLevelEnvVarName: string;\n\n  /**\n   * The namespace of the logger.\n   */\n  namespace: string;\n}\n\nconst TYPESPEC_RUNTIME_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\n\ntype DebuggerWithLogLevel = Debugger & { level: TypeSpecRuntimeLogLevel };\n\nconst levelMap = {\n  verbose: 400,\n  info: 300,\n  warning: 200,\n  error: 100,\n};\n\nfunction patchLogMethod(\n  parent: TypeSpecRuntimeClientLogger,\n  child: TypeSpecRuntimeClientLogger | DebuggerWithLogLevel,\n): void {\n  child.log = (...args) => {\n    parent.log(...args);\n  };\n}\n\nfunction isTypeSpecRuntimeLogLevel(level: string): level is TypeSpecRuntimeLogLevel {\n  return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level as any);\n}\n\n/**\n * Creates a logger context base on the provided options.\n * @param options - The options for creating a logger context.\n * @returns The logger context.\n */\nexport function createLoggerContext(options: CreateLoggerContextOptions): LoggerContext {\n  const registeredLoggers = new Set<DebuggerWithLogLevel>();\n  const logLevelFromEnv =\n    (typeof process !== \"undefined\" && process.env && process.env[options.logLevelEnvVarName]) ||\n    undefined;\n\n  let logLevel: TypeSpecRuntimeLogLevel | undefined;\n\n  const clientLogger: TypeSpecRuntimeClientLogger = debug(options.namespace);\n  clientLogger.log = (...args) => {\n    debug.log(...args);\n  };\n\n  function contextSetLogLevel(level?: TypeSpecRuntimeLogLevel): void {\n    if (level && !isTypeSpecRuntimeLogLevel(level)) {\n      throw new Error(\n        `Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(\",\")}`,\n      );\n    }\n    logLevel = level;\n\n    const enabledNamespaces = [];\n    for (const logger of registeredLoggers) {\n      if (shouldEnable(logger)) {\n        enabledNamespaces.push(logger.namespace);\n      }\n    }\n\n    debug.enable(enabledNamespaces.join(\",\"));\n  }\n\n  if (logLevelFromEnv) {\n    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n    if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {\n      contextSetLogLevel(logLevelFromEnv);\n    } else {\n      console.error(\n        `${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(\n          \", \",\n        )}.`,\n      );\n    }\n  }\n\n  function shouldEnable(logger: DebuggerWithLogLevel): boolean {\n    return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);\n  }\n\n  function createLogger(\n    parent: TypeSpecRuntimeClientLogger,\n    level: TypeSpecRuntimeLogLevel,\n  ): DebuggerWithLogLevel {\n    const logger: DebuggerWithLogLevel = Object.assign(parent.extend(level), {\n      level,\n    });\n\n    patchLogMethod(parent, logger);\n\n    if (shouldEnable(logger)) {\n      const enabledNamespaces = debug.disable();\n      debug.enable(enabledNamespaces + \",\" + logger.namespace);\n    }\n\n    registeredLoggers.add(logger);\n\n    return logger;\n  }\n\n  function contextGetLogLevel(): TypeSpecRuntimeLogLevel | undefined {\n    return logLevel;\n  }\n\n  function contextCreateClientLogger(namespace: string): TypeSpecRuntimeLogger {\n    const clientRootLogger: TypeSpecRuntimeClientLogger = clientLogger.extend(namespace);\n    patchLogMethod(clientLogger, clientRootLogger);\n    return {\n      error: createLogger(clientRootLogger, \"error\"),\n      warning: createLogger(clientRootLogger, \"warning\"),\n      info: createLogger(clientRootLogger, \"info\"),\n      verbose: createLogger(clientRootLogger, \"verbose\"),\n    };\n  }\n\n  return {\n    setLogLevel: contextSetLogLevel,\n    getLogLevel: contextGetLogLevel,\n    createClientLogger: contextCreateClientLogger,\n    logger: clientLogger,\n  };\n}\n\nconst context = createLoggerContext({\n  logLevelEnvVarName: \"TYPESPEC_RUNTIME_LOG_LEVEL\",\n  namespace: \"typeSpecRuntime\",\n});\n\n/**\n * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n * @param level - The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const TypeSpecRuntimeLogger: TypeSpecRuntimeClientLogger = context.logger;\n\n/**\n * Retrieves the currently specified log level.\n */\nexport function setLogLevel(logLevel?: TypeSpecRuntimeLogLevel): void {\n  context.setLogLevel(logLevel);\n}\n\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel(): TypeSpecRuntimeLogLevel | undefined {\n  return context.getLogLevel();\n}\n\n/**\n * Creates a logger for use by the SDKs that inherits from `TypeSpecRuntimeLogger`.\n * @param namespace - The name of the SDK package.\n * @hidden\n */\nexport function createClientLogger(namespace: string): TypeSpecRuntimeLogger {\n  return context.createClientLogger(namespace);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}