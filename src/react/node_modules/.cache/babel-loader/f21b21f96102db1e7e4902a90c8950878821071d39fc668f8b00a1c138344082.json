{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { setContinuationToken } from \"../pagingHelper.js\";\nimport * as coreClient from \"@azure/core-client\";\nimport * as Mappers from \"../models/mappers.js\";\nimport * as Parameters from \"../models/parameters.js\";\nimport { createHttpPoller } from \"@azure/core-lro\";\nimport { createLroSpec } from \"../lroImpl.js\";\n/// <reference lib=\"esnext.asynciterable\" />\n/** Class containing Deployments operations. */\nexport class DeploymentsImpl {\n  /**\n   * Initialize a new instance of the class Deployments class.\n   * @param client Reference to the service client\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  /**\n   * Get all the deployments at the given scope.\n   * @param scope The resource scope.\n   * @param options The options parameters.\n   */\n  listAtScope(scope, options) {\n    const iter = this.listAtScopePagingAll(scope, options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: settings => {\n        if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listAtScopePagingPage(scope, options, settings);\n      }\n    };\n  }\n  listAtScopePagingPage(scope, options, settings) {\n    return __asyncGenerator(this, arguments, function* listAtScopePagingPage_1() {\n      let result;\n      let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;\n      if (!continuationToken) {\n        result = yield __await(this._listAtScope(scope, options));\n        let page = result.value || [];\n        continuationToken = result.nextLink;\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n      while (continuationToken) {\n        result = yield __await(this._listAtScopeNext(scope, continuationToken, options));\n        continuationToken = result.nextLink;\n        let page = result.value || [];\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n    });\n  }\n  listAtScopePagingAll(scope, options) {\n    return __asyncGenerator(this, arguments, function* listAtScopePagingAll_1() {\n      var _a, e_1, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listAtScopePagingPage(scope, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  /**\n   * Get all the deployments at the tenant scope.\n   * @param options The options parameters.\n   */\n  listAtTenantScope(options) {\n    const iter = this.listAtTenantScopePagingAll(options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: settings => {\n        if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listAtTenantScopePagingPage(options, settings);\n      }\n    };\n  }\n  listAtTenantScopePagingPage(options, settings) {\n    return __asyncGenerator(this, arguments, function* listAtTenantScopePagingPage_1() {\n      let result;\n      let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;\n      if (!continuationToken) {\n        result = yield __await(this._listAtTenantScope(options));\n        let page = result.value || [];\n        continuationToken = result.nextLink;\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n      while (continuationToken) {\n        result = yield __await(this._listAtTenantScopeNext(continuationToken, options));\n        continuationToken = result.nextLink;\n        let page = result.value || [];\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n    });\n  }\n  listAtTenantScopePagingAll(options) {\n    return __asyncGenerator(this, arguments, function* listAtTenantScopePagingAll_1() {\n      var _a, e_2, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listAtTenantScopePagingPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  /**\n   * Get all the deployments for a management group.\n   * @param groupId The management group ID.\n   * @param options The options parameters.\n   */\n  listAtManagementGroupScope(groupId, options) {\n    const iter = this.listAtManagementGroupScopePagingAll(groupId, options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: settings => {\n        if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listAtManagementGroupScopePagingPage(groupId, options, settings);\n      }\n    };\n  }\n  listAtManagementGroupScopePagingPage(groupId, options, settings) {\n    return __asyncGenerator(this, arguments, function* listAtManagementGroupScopePagingPage_1() {\n      let result;\n      let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;\n      if (!continuationToken) {\n        result = yield __await(this._listAtManagementGroupScope(groupId, options));\n        let page = result.value || [];\n        continuationToken = result.nextLink;\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n      while (continuationToken) {\n        result = yield __await(this._listAtManagementGroupScopeNext(groupId, continuationToken, options));\n        continuationToken = result.nextLink;\n        let page = result.value || [];\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n    });\n  }\n  listAtManagementGroupScopePagingAll(groupId, options) {\n    return __asyncGenerator(this, arguments, function* listAtManagementGroupScopePagingAll_1() {\n      var _a, e_3, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listAtManagementGroupScopePagingPage(groupId, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    });\n  }\n  /**\n   * Get all the deployments for a subscription.\n   * @param options The options parameters.\n   */\n  listAtSubscriptionScope(options) {\n    const iter = this.listAtSubscriptionScopePagingAll(options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: settings => {\n        if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listAtSubscriptionScopePagingPage(options, settings);\n      }\n    };\n  }\n  listAtSubscriptionScopePagingPage(options, settings) {\n    return __asyncGenerator(this, arguments, function* listAtSubscriptionScopePagingPage_1() {\n      let result;\n      let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;\n      if (!continuationToken) {\n        result = yield __await(this._listAtSubscriptionScope(options));\n        let page = result.value || [];\n        continuationToken = result.nextLink;\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n      while (continuationToken) {\n        result = yield __await(this._listAtSubscriptionScopeNext(continuationToken, options));\n        continuationToken = result.nextLink;\n        let page = result.value || [];\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n    });\n  }\n  listAtSubscriptionScopePagingAll(options) {\n    return __asyncGenerator(this, arguments, function* listAtSubscriptionScopePagingAll_1() {\n      var _a, e_4, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listAtSubscriptionScopePagingPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    });\n  }\n  /**\n   * Get all the deployments for a resource group.\n   * @param resourceGroupName The name of the resource group with the deployments to get. The name is\n   *                          case insensitive.\n   * @param options The options parameters.\n   */\n  listByResourceGroup(resourceGroupName, options) {\n    const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: settings => {\n        if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);\n      }\n    };\n  }\n  listByResourceGroupPagingPage(resourceGroupName, options, settings) {\n    return __asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {\n      let result;\n      let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;\n      if (!continuationToken) {\n        result = yield __await(this._listByResourceGroup(resourceGroupName, options));\n        let page = result.value || [];\n        continuationToken = result.nextLink;\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n      while (continuationToken) {\n        result = yield __await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));\n        continuationToken = result.nextLink;\n        let page = result.value || [];\n        setContinuationToken(page, continuationToken);\n        yield yield __await(page);\n      }\n    });\n  }\n  listByResourceGroupPagingAll(resourceGroupName, options) {\n    return __asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {\n      var _a, e_5, _b, _c;\n      try {\n        for (var _d = true, _e = __asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n    });\n  }\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtScope(scope, deploymentName, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        scope,\n        deploymentName,\n        options\n      },\n      spec: deleteAtScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtScopeAndWait(scope, deploymentName, options) {\n    const poller = await this.beginDeleteAtScope(scope, deploymentName, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Checks whether the deployment exists.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  checkExistenceAtScope(scope, deploymentName, options) {\n    return this.client.sendOperationRequest({\n      scope,\n      deploymentName,\n      options\n    }, checkExistenceAtScopeOperationSpec);\n  }\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtScope(scope, deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        scope,\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: createOrUpdateAtScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtScopeAndWait(scope, deploymentName, parameters, options) {\n    const poller = await this.beginCreateOrUpdateAtScope(scope, deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Gets a deployment.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  getAtScope(scope, deploymentName, options) {\n    return this.client.sendOperationRequest({\n      scope,\n      deploymentName,\n      options\n    }, getAtScopeOperationSpec);\n  }\n  /**\n   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the\n   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment\n   * stops the currently running template deployment and leaves the resources partially deployed.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  cancelAtScope(scope, deploymentName, options) {\n    return this.client.sendOperationRequest({\n      scope,\n      deploymentName,\n      options\n    }, cancelAtScopeOperationSpec);\n  }\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtScope(scope, deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        scope,\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: validateAtScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtScopeAndWait(scope, deploymentName, parameters, options) {\n    const poller = await this.beginValidateAtScope(scope, deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Exports the template used for specified deployment.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  exportTemplateAtScope(scope, deploymentName, options) {\n    return this.client.sendOperationRequest({\n      scope,\n      deploymentName,\n      options\n    }, exportTemplateAtScopeOperationSpec);\n  }\n  /**\n   * Get all the deployments at the given scope.\n   * @param scope The resource scope.\n   * @param options The options parameters.\n   */\n  _listAtScope(scope, options) {\n    return this.client.sendOperationRequest({\n      scope,\n      options\n    }, listAtScopeOperationSpec);\n  }\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtTenantScope(deploymentName, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        deploymentName,\n        options\n      },\n      spec: deleteAtTenantScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtTenantScopeAndWait(deploymentName, options) {\n    const poller = await this.beginDeleteAtTenantScope(deploymentName, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Checks whether the deployment exists.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  checkExistenceAtTenantScope(deploymentName, options) {\n    return this.client.sendOperationRequest({\n      deploymentName,\n      options\n    }, checkExistenceAtTenantScopeOperationSpec);\n  }\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtTenantScope(deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: createOrUpdateAtTenantScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtTenantScopeAndWait(deploymentName, parameters, options) {\n    const poller = await this.beginCreateOrUpdateAtTenantScope(deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Gets a deployment.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  getAtTenantScope(deploymentName, options) {\n    return this.client.sendOperationRequest({\n      deploymentName,\n      options\n    }, getAtTenantScopeOperationSpec);\n  }\n  /**\n   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the\n   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment\n   * stops the currently running template deployment and leaves the resources partially deployed.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  cancelAtTenantScope(deploymentName, options) {\n    return this.client.sendOperationRequest({\n      deploymentName,\n      options\n    }, cancelAtTenantScopeOperationSpec);\n  }\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtTenantScope(deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: validateAtTenantScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtTenantScopeAndWait(deploymentName, parameters, options) {\n    const poller = await this.beginValidateAtTenantScope(deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the tenant group.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAtTenantScope(deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: whatIfAtTenantScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,\n      resourceLocationConfig: \"location\"\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the tenant group.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAtTenantScopeAndWait(deploymentName, parameters, options) {\n    const poller = await this.beginWhatIfAtTenantScope(deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Exports the template used for specified deployment.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  exportTemplateAtTenantScope(deploymentName, options) {\n    return this.client.sendOperationRequest({\n      deploymentName,\n      options\n    }, exportTemplateAtTenantScopeOperationSpec);\n  }\n  /**\n   * Get all the deployments at the tenant scope.\n   * @param options The options parameters.\n   */\n  _listAtTenantScope(options) {\n    return this.client.sendOperationRequest({\n      options\n    }, listAtTenantScopeOperationSpec);\n  }\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtManagementGroupScope(groupId, deploymentName, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        groupId,\n        deploymentName,\n        options\n      },\n      spec: deleteAtManagementGroupScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtManagementGroupScopeAndWait(groupId, deploymentName, options) {\n    const poller = await this.beginDeleteAtManagementGroupScope(groupId, deploymentName, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Checks whether the deployment exists.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  checkExistenceAtManagementGroupScope(groupId, deploymentName, options) {\n    return this.client.sendOperationRequest({\n      groupId,\n      deploymentName,\n      options\n    }, checkExistenceAtManagementGroupScopeOperationSpec);\n  }\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtManagementGroupScope(groupId, deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        groupId,\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: createOrUpdateAtManagementGroupScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtManagementGroupScopeAndWait(groupId, deploymentName, parameters, options) {\n    const poller = await this.beginCreateOrUpdateAtManagementGroupScope(groupId, deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Gets a deployment.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  getAtManagementGroupScope(groupId, deploymentName, options) {\n    return this.client.sendOperationRequest({\n      groupId,\n      deploymentName,\n      options\n    }, getAtManagementGroupScopeOperationSpec);\n  }\n  /**\n   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the\n   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment\n   * stops the currently running template deployment and leaves the resources partially deployed.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  cancelAtManagementGroupScope(groupId, deploymentName, options) {\n    return this.client.sendOperationRequest({\n      groupId,\n      deploymentName,\n      options\n    }, cancelAtManagementGroupScopeOperationSpec);\n  }\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtManagementGroupScope(groupId, deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        groupId,\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: validateAtManagementGroupScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtManagementGroupScopeAndWait(groupId, deploymentName, parameters, options) {\n    const poller = await this.beginValidateAtManagementGroupScope(groupId, deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the management\n   * group.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAtManagementGroupScope(groupId, deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        groupId,\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: whatIfAtManagementGroupScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,\n      resourceLocationConfig: \"location\"\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the management\n   * group.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAtManagementGroupScopeAndWait(groupId, deploymentName, parameters, options) {\n    const poller = await this.beginWhatIfAtManagementGroupScope(groupId, deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Exports the template used for specified deployment.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  exportTemplateAtManagementGroupScope(groupId, deploymentName, options) {\n    return this.client.sendOperationRequest({\n      groupId,\n      deploymentName,\n      options\n    }, exportTemplateAtManagementGroupScopeOperationSpec);\n  }\n  /**\n   * Get all the deployments for a management group.\n   * @param groupId The management group ID.\n   * @param options The options parameters.\n   */\n  _listAtManagementGroupScope(groupId, options) {\n    return this.client.sendOperationRequest({\n      groupId,\n      options\n    }, listAtManagementGroupScopeOperationSpec);\n  }\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtSubscriptionScope(deploymentName, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        deploymentName,\n        options\n      },\n      spec: deleteAtSubscriptionScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtSubscriptionScopeAndWait(deploymentName, options) {\n    const poller = await this.beginDeleteAtSubscriptionScope(deploymentName, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Checks whether the deployment exists.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  checkExistenceAtSubscriptionScope(deploymentName, options) {\n    return this.client.sendOperationRequest({\n      deploymentName,\n      options\n    }, checkExistenceAtSubscriptionScopeOperationSpec);\n  }\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtSubscriptionScope(deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: createOrUpdateAtSubscriptionScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtSubscriptionScopeAndWait(deploymentName, parameters, options) {\n    const poller = await this.beginCreateOrUpdateAtSubscriptionScope(deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Gets a deployment.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  getAtSubscriptionScope(deploymentName, options) {\n    return this.client.sendOperationRequest({\n      deploymentName,\n      options\n    }, getAtSubscriptionScopeOperationSpec);\n  }\n  /**\n   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the\n   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment\n   * stops the currently running template deployment and leaves the resources partially deployed.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  cancelAtSubscriptionScope(deploymentName, options) {\n    return this.client.sendOperationRequest({\n      deploymentName,\n      options\n    }, cancelAtSubscriptionScopeOperationSpec);\n  }\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtSubscriptionScope(deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: validateAtSubscriptionScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtSubscriptionScopeAndWait(deploymentName, parameters, options) {\n    const poller = await this.beginValidateAtSubscriptionScope(deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the subscription.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to What If.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAtSubscriptionScope(deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: whatIfAtSubscriptionScopeOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,\n      resourceLocationConfig: \"location\"\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the subscription.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to What If.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAtSubscriptionScopeAndWait(deploymentName, parameters, options) {\n    const poller = await this.beginWhatIfAtSubscriptionScope(deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Exports the template used for specified deployment.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  exportTemplateAtSubscriptionScope(deploymentName, options) {\n    return this.client.sendOperationRequest({\n      deploymentName,\n      options\n    }, exportTemplateAtSubscriptionScopeOperationSpec);\n  }\n  /**\n   * Get all the deployments for a subscription.\n   * @param options The options parameters.\n   */\n  _listAtSubscriptionScope(options) {\n    return this.client.sendOperationRequest({\n      options\n    }, listAtSubscriptionScopeOperationSpec);\n  }\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. Deleting a template deployment does not affect the\n   * state of the resource group. This is an asynchronous operation that returns a status of 202 until\n   * the template deployment is successfully deleted. The Location response header contains the URI that\n   * is used to obtain the status of the process. While the process is running, a call to the URI in the\n   * Location header returns a status of 202. When the process finishes, the URI in the Location header\n   * returns a status of 204 on success. If the asynchronous request failed, the URI in the Location\n   * header returns an error-level status code.\n   * @param resourceGroupName The name of the resource group with the deployment to delete. The name is\n   *                          case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDelete(resourceGroupName, deploymentName, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceGroupName,\n        deploymentName,\n        options\n      },\n      spec: deleteOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. Deleting a template deployment does not affect the\n   * state of the resource group. This is an asynchronous operation that returns a status of 202 until\n   * the template deployment is successfully deleted. The Location response header contains the URI that\n   * is used to obtain the status of the process. While the process is running, a call to the URI in the\n   * Location header returns a status of 202. When the process finishes, the URI in the Location header\n   * returns a status of 204 on success. If the asynchronous request failed, the URI in the Location\n   * header returns an error-level status code.\n   * @param resourceGroupName The name of the resource group with the deployment to delete. The name is\n   *                          case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAndWait(resourceGroupName, deploymentName, options) {\n    const poller = await this.beginDelete(resourceGroupName, deploymentName, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Checks whether the deployment exists.\n   * @param resourceGroupName The name of the resource group with the deployment to check. The name is\n   *                          case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  checkExistence(resourceGroupName, deploymentName, options) {\n    return this.client.sendOperationRequest({\n      resourceGroupName,\n      deploymentName,\n      options\n    }, checkExistenceOperationSpec);\n  }\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param resourceGroupName The name of the resource group to deploy the resources to. The name is case\n   *                          insensitive. The resource group must already exist.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdate(resourceGroupName, deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceGroupName,\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: createOrUpdateOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param resourceGroupName The name of the resource group to deploy the resources to. The name is case\n   *                          insensitive. The resource group must already exist.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAndWait(resourceGroupName, deploymentName, parameters, options) {\n    const poller = await this.beginCreateOrUpdate(resourceGroupName, deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Gets a deployment.\n   * @param resourceGroupName The name of the resource group. The name is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  get(resourceGroupName, deploymentName, options) {\n    return this.client.sendOperationRequest({\n      resourceGroupName,\n      deploymentName,\n      options\n    }, getOperationSpec);\n  }\n  /**\n   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the\n   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment\n   * stops the currently running template deployment and leaves the resource group partially deployed.\n   * @param resourceGroupName The name of the resource group. The name is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  cancel(resourceGroupName, deploymentName, options) {\n    return this.client.sendOperationRequest({\n      resourceGroupName,\n      deploymentName,\n      options\n    }, cancelOperationSpec);\n  }\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param resourceGroupName The name of the resource group the template will be deployed to. The name\n   *                          is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidate(resourceGroupName, deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceGroupName,\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: validateOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param resourceGroupName The name of the resource group the template will be deployed to. The name\n   *                          is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAndWait(resourceGroupName, deploymentName, parameters, options) {\n    const poller = await this.beginValidate(resourceGroupName, deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the resource group.\n   * @param resourceGroupName The name of the resource group the template will be deployed to. The name\n   *                          is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginWhatIf(resourceGroupName, deploymentName, parameters, options) {\n    const directSendOperation = async (args, spec) => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (args, spec) => {\n      var _a;\n      let currentRawResponse = undefined;\n      const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;\n      const callback = (rawResponse, flatResponse) => {\n        currentRawResponse = rawResponse;\n        providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);\n      };\n      const updatedArgs = Object.assign(Object.assign({}, args), {\n        options: Object.assign(Object.assign({}, args.options), {\n          onResponse: callback\n        })\n      });\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse.status,\n          body: currentRawResponse.parsedBody,\n          headers: currentRawResponse.headers.toJSON()\n        }\n      };\n    };\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: {\n        resourceGroupName,\n        deploymentName,\n        parameters,\n        options\n      },\n      spec: whatIfOperationSpec\n    });\n    const poller = await createHttpPoller(lro, {\n      restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,\n      intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,\n      resourceLocationConfig: \"location\"\n    });\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the resource group.\n   * @param resourceGroupName The name of the resource group the template will be deployed to. The name\n   *                          is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAndWait(resourceGroupName, deploymentName, parameters, options) {\n    const poller = await this.beginWhatIf(resourceGroupName, deploymentName, parameters, options);\n    return poller.pollUntilDone();\n  }\n  /**\n   * Exports the template used for specified deployment.\n   * @param resourceGroupName The name of the resource group. The name is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  exportTemplate(resourceGroupName, deploymentName, options) {\n    return this.client.sendOperationRequest({\n      resourceGroupName,\n      deploymentName,\n      options\n    }, exportTemplateOperationSpec);\n  }\n  /**\n   * Get all the deployments for a resource group.\n   * @param resourceGroupName The name of the resource group with the deployments to get. The name is\n   *                          case insensitive.\n   * @param options The options parameters.\n   */\n  _listByResourceGroup(resourceGroupName, options) {\n    return this.client.sendOperationRequest({\n      resourceGroupName,\n      options\n    }, listByResourceGroupOperationSpec);\n  }\n  /**\n   * Calculate the hash of the given template.\n   * @param template The template provided to calculate hash.\n   * @param options The options parameters.\n   */\n  calculateTemplateHash(template, options) {\n    return this.client.sendOperationRequest({\n      template,\n      options\n    }, calculateTemplateHashOperationSpec);\n  }\n  /**\n   * ListAtScopeNext\n   * @param scope The resource scope.\n   * @param nextLink The nextLink from the previous successful call to the ListAtScope method.\n   * @param options The options parameters.\n   */\n  _listAtScopeNext(scope, nextLink, options) {\n    return this.client.sendOperationRequest({\n      scope,\n      nextLink,\n      options\n    }, listAtScopeNextOperationSpec);\n  }\n  /**\n   * ListAtTenantScopeNext\n   * @param nextLink The nextLink from the previous successful call to the ListAtTenantScope method.\n   * @param options The options parameters.\n   */\n  _listAtTenantScopeNext(nextLink, options) {\n    return this.client.sendOperationRequest({\n      nextLink,\n      options\n    }, listAtTenantScopeNextOperationSpec);\n  }\n  /**\n   * ListAtManagementGroupScopeNext\n   * @param groupId The management group ID.\n   * @param nextLink The nextLink from the previous successful call to the ListAtManagementGroupScope\n   *                 method.\n   * @param options The options parameters.\n   */\n  _listAtManagementGroupScopeNext(groupId, nextLink, options) {\n    return this.client.sendOperationRequest({\n      groupId,\n      nextLink,\n      options\n    }, listAtManagementGroupScopeNextOperationSpec);\n  }\n  /**\n   * ListAtSubscriptionScopeNext\n   * @param nextLink The nextLink from the previous successful call to the ListAtSubscriptionScope\n   *                 method.\n   * @param options The options parameters.\n   */\n  _listAtSubscriptionScopeNext(nextLink, options) {\n    return this.client.sendOperationRequest({\n      nextLink,\n      options\n    }, listAtSubscriptionScopeNextOperationSpec);\n  }\n  /**\n   * ListByResourceGroupNext\n   * @param resourceGroupName The name of the resource group with the deployments to get. The name is\n   *                          case insensitive.\n   * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.\n   * @param options The options parameters.\n   */\n  _listByResourceGroupNext(resourceGroupName, nextLink, options) {\n    return this.client.sendOperationRequest({\n      resourceGroupName,\n      nextLink,\n      options\n    }, listByResourceGroupNextOperationSpec);\n  }\n}\n// Operation Specifications\nconst serializer = coreClient.createSerializer(Mappers, /* isXml */false);\nconst deleteAtScopeOperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.scope, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst checkExistenceAtScopeOperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"HEAD\",\n  responses: {\n    204: {},\n    404: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.scope, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst createOrUpdateAtScopeOperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.scope, Parameters.deploymentName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst getAtScopeOperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.scope, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst cancelAtScopeOperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel\",\n  httpMethod: \"POST\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.scope, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst validateAtScopeOperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/validate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.scope, Parameters.deploymentName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst exportTemplateAtScopeOperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExportResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.scope, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listAtScopeOperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],\n  urlParameters: [Parameters.$host, Parameters.scope],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst deleteAtTenantScopeOperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst checkExistenceAtTenantScopeOperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"HEAD\",\n  responses: {\n    204: {},\n    404: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst createOrUpdateAtTenantScopeOperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters1,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst getAtTenantScopeOperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst cancelAtTenantScopeOperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}/cancel\",\n  httpMethod: \"POST\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst validateAtTenantScopeOperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}/validate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters1,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst whatIfAtTenantScopeOperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    201: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    202: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    204: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters2,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst exportTemplateAtTenantScopeOperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExportResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listAtTenantScopeOperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],\n  urlParameters: [Parameters.$host],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst deleteAtManagementGroupScopeOperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.groupId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst checkExistenceAtManagementGroupScopeOperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"HEAD\",\n  responses: {\n    204: {},\n    404: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.groupId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst createOrUpdateAtManagementGroupScopeOperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters1,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.groupId],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst getAtManagementGroupScopeOperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.groupId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst cancelAtManagementGroupScopeOperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel\",\n  httpMethod: \"POST\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.groupId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst validateAtManagementGroupScopeOperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters1,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.groupId],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst whatIfAtManagementGroupScopeOperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    201: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    202: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    204: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters2,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.groupId],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst exportTemplateAtManagementGroupScopeOperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExportResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.groupId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listAtManagementGroupScopeOperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],\n  urlParameters: [Parameters.$host, Parameters.groupId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst deleteAtSubscriptionScopeOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst checkExistenceAtSubscriptionScopeOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"HEAD\",\n  responses: {\n    204: {},\n    404: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst createOrUpdateAtSubscriptionScopeOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst getAtSubscriptionScopeOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst cancelAtSubscriptionScopeOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel\",\n  httpMethod: \"POST\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst validateAtSubscriptionScopeOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst whatIfAtSubscriptionScopeOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    201: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    202: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    204: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters3,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst exportTemplateAtSubscriptionScopeOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExportResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listAtSubscriptionScopeOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst deleteOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId, Parameters.resourceGroupName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst checkExistenceOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"HEAD\",\n  responses: {\n    204: {},\n    404: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId, Parameters.resourceGroupName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst createOrUpdateOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId, Parameters.resourceGroupName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst getOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId, Parameters.resourceGroupName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst cancelOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel\",\n  httpMethod: \"POST\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId, Parameters.resourceGroupName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst validateOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentValidateResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId, Parameters.resourceGroupName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst whatIfOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    201: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    202: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    204: {\n      bodyMapper: Mappers.WhatIfOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.parameters3,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId, Parameters.resourceGroupName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst exportTemplateOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExportResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName, Parameters.subscriptionId, Parameters.resourceGroupName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listByResourceGroupOperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId, Parameters.resourceGroupName],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst calculateTemplateHashOperationSpec = {\n  path: \"/providers/Microsoft.Resources/calculateTemplateHash\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.TemplateHashResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  requestBody: Parameters.template,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer\n};\nconst listAtScopeNextOperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.scope],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listAtTenantScopeNextOperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  urlParameters: [Parameters.$host, Parameters.nextLink],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listAtManagementGroupScopeNextOperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.groupId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listAtSubscriptionScopeNextOperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst listByResourceGroupNextOperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult\n    },\n    default: {\n      bodyMapper: Mappers.CloudError\n    }\n  },\n  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.subscriptionId, Parameters.resourceGroupName],\n  headerParameters: [Parameters.accept],\n  serializer\n};","map":{"version":3,"names":["setContinuationToken","coreClient","Mappers","Parameters","createHttpPoller","createLroSpec","DeploymentsImpl","constructor","client","listAtScope","scope","options","iter","listAtScopePagingAll","next","Symbol","asyncIterator","byPage","settings","maxPageSize","Error","listAtScopePagingPage","result","continuationToken","__await","_listAtScope","page","value","nextLink","_listAtScopeNext","_d","_e","__asyncValues","_f","_a","done","_c","__asyncDelegator","listAtTenantScope","listAtTenantScopePagingAll","listAtTenantScopePagingPage","_listAtTenantScope","_listAtTenantScopeNext","listAtManagementGroupScope","groupId","listAtManagementGroupScopePagingAll","listAtManagementGroupScopePagingPage","_listAtManagementGroupScope","_listAtManagementGroupScopeNext","listAtSubscriptionScope","listAtSubscriptionScopePagingAll","listAtSubscriptionScopePagingPage","_listAtSubscriptionScope","_listAtSubscriptionScopeNext","listByResourceGroup","resourceGroupName","listByResourceGroupPagingAll","listByResourceGroupPagingPage","_listByResourceGroup","_listByResourceGroupNext","beginDeleteAtScope","deploymentName","directSendOperation","args","spec","sendOperationRequest","sendOperationFn","currentRawResponse","undefined","providedCallback","onResponse","callback","rawResponse","flatResponse","updatedArgs","Object","assign","statusCode","status","body","parsedBody","headers","toJSON","lro","deleteAtScopeOperationSpec","poller","restoreFrom","resumeFrom","intervalInMs","updateIntervalInMs","poll","beginDeleteAtScopeAndWait","pollUntilDone","checkExistenceAtScope","checkExistenceAtScopeOperationSpec","beginCreateOrUpdateAtScope","parameters","createOrUpdateAtScopeOperationSpec","beginCreateOrUpdateAtScopeAndWait","getAtScope","getAtScopeOperationSpec","cancelAtScope","cancelAtScopeOperationSpec","beginValidateAtScope","validateAtScopeOperationSpec","beginValidateAtScopeAndWait","exportTemplateAtScope","exportTemplateAtScopeOperationSpec","listAtScopeOperationSpec","beginDeleteAtTenantScope","deleteAtTenantScopeOperationSpec","beginDeleteAtTenantScopeAndWait","checkExistenceAtTenantScope","checkExistenceAtTenantScopeOperationSpec","beginCreateOrUpdateAtTenantScope","createOrUpdateAtTenantScopeOperationSpec","beginCreateOrUpdateAtTenantScopeAndWait","getAtTenantScope","getAtTenantScopeOperationSpec","cancelAtTenantScope","cancelAtTenantScopeOperationSpec","beginValidateAtTenantScope","validateAtTenantScopeOperationSpec","beginValidateAtTenantScopeAndWait","beginWhatIfAtTenantScope","whatIfAtTenantScopeOperationSpec","resourceLocationConfig","beginWhatIfAtTenantScopeAndWait","exportTemplateAtTenantScope","exportTemplateAtTenantScopeOperationSpec","listAtTenantScopeOperationSpec","beginDeleteAtManagementGroupScope","deleteAtManagementGroupScopeOperationSpec","beginDeleteAtManagementGroupScopeAndWait","checkExistenceAtManagementGroupScope","checkExistenceAtManagementGroupScopeOperationSpec","beginCreateOrUpdateAtManagementGroupScope","createOrUpdateAtManagementGroupScopeOperationSpec","beginCreateOrUpdateAtManagementGroupScopeAndWait","getAtManagementGroupScope","getAtManagementGroupScopeOperationSpec","cancelAtManagementGroupScope","cancelAtManagementGroupScopeOperationSpec","beginValidateAtManagementGroupScope","validateAtManagementGroupScopeOperationSpec","beginValidateAtManagementGroupScopeAndWait","beginWhatIfAtManagementGroupScope","whatIfAtManagementGroupScopeOperationSpec","beginWhatIfAtManagementGroupScopeAndWait","exportTemplateAtManagementGroupScope","exportTemplateAtManagementGroupScopeOperationSpec","listAtManagementGroupScopeOperationSpec","beginDeleteAtSubscriptionScope","deleteAtSubscriptionScopeOperationSpec","beginDeleteAtSubscriptionScopeAndWait","checkExistenceAtSubscriptionScope","checkExistenceAtSubscriptionScopeOperationSpec","beginCreateOrUpdateAtSubscriptionScope","createOrUpdateAtSubscriptionScopeOperationSpec","beginCreateOrUpdateAtSubscriptionScopeAndWait","getAtSubscriptionScope","getAtSubscriptionScopeOperationSpec","cancelAtSubscriptionScope","cancelAtSubscriptionScopeOperationSpec","beginValidateAtSubscriptionScope","validateAtSubscriptionScopeOperationSpec","beginValidateAtSubscriptionScopeAndWait","beginWhatIfAtSubscriptionScope","whatIfAtSubscriptionScopeOperationSpec","beginWhatIfAtSubscriptionScopeAndWait","exportTemplateAtSubscriptionScope","exportTemplateAtSubscriptionScopeOperationSpec","listAtSubscriptionScopeOperationSpec","beginDelete","deleteOperationSpec","beginDeleteAndWait","checkExistence","checkExistenceOperationSpec","beginCreateOrUpdate","createOrUpdateOperationSpec","beginCreateOrUpdateAndWait","get","getOperationSpec","cancel","cancelOperationSpec","beginValidate","validateOperationSpec","beginValidateAndWait","beginWhatIf","whatIfOperationSpec","beginWhatIfAndWait","exportTemplate","exportTemplateOperationSpec","listByResourceGroupOperationSpec","calculateTemplateHash","template","calculateTemplateHashOperationSpec","listAtScopeNextOperationSpec","listAtTenantScopeNextOperationSpec","listAtManagementGroupScopeNextOperationSpec","listAtSubscriptionScopeNextOperationSpec","listByResourceGroupNextOperationSpec","serializer","createSerializer","path","httpMethod","responses","default","bodyMapper","CloudError","queryParameters","apiVersion","urlParameters","$host","headerParameters","accept","DeploymentExtended","requestBody","contentType","mediaType","DeploymentValidateResult","DeploymentExportResult","DeploymentListResult","filter","top","parameters1","WhatIfOperationResult","parameters2","subscriptionId","parameters3","TemplateHashResult"],"sources":["/home/runner/work/Azure-Service-Deployment-Web/Azure-Service-Deployment-Web/node_modules/@azure/arm-resources/src/operations/deployments.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport { PagedAsyncIterableIterator, PageSettings } from \"@azure/core-paging\";\nimport { setContinuationToken } from \"../pagingHelper.js\";\nimport { Deployments } from \"../operationsInterfaces/index.js\";\nimport * as coreClient from \"@azure/core-client\";\nimport * as Mappers from \"../models/mappers.js\";\nimport * as Parameters from \"../models/parameters.js\";\nimport { ResourceManagementClient } from \"../resourceManagementClient.js\";\nimport {\n  SimplePollerLike,\n  OperationState,\n  createHttpPoller,\n} from \"@azure/core-lro\";\nimport { createLroSpec } from \"../lroImpl.js\";\nimport {\n  DeploymentExtended,\n  DeploymentsListAtScopeNextOptionalParams,\n  DeploymentsListAtScopeOptionalParams,\n  DeploymentsListAtScopeResponse,\n  DeploymentsListAtTenantScopeNextOptionalParams,\n  DeploymentsListAtTenantScopeOptionalParams,\n  DeploymentsListAtTenantScopeResponse,\n  DeploymentsListAtManagementGroupScopeNextOptionalParams,\n  DeploymentsListAtManagementGroupScopeOptionalParams,\n  DeploymentsListAtManagementGroupScopeResponse,\n  DeploymentsListAtSubscriptionScopeNextOptionalParams,\n  DeploymentsListAtSubscriptionScopeOptionalParams,\n  DeploymentsListAtSubscriptionScopeResponse,\n  DeploymentsListByResourceGroupNextOptionalParams,\n  DeploymentsListByResourceGroupOptionalParams,\n  DeploymentsListByResourceGroupResponse,\n  DeploymentsDeleteAtScopeOptionalParams,\n  DeploymentsCheckExistenceAtScopeOptionalParams,\n  DeploymentsCheckExistenceAtScopeResponse,\n  Deployment,\n  DeploymentsCreateOrUpdateAtScopeOptionalParams,\n  DeploymentsCreateOrUpdateAtScopeResponse,\n  DeploymentsGetAtScopeOptionalParams,\n  DeploymentsGetAtScopeResponse,\n  DeploymentsCancelAtScopeOptionalParams,\n  DeploymentsValidateAtScopeOptionalParams,\n  DeploymentsValidateAtScopeResponse,\n  DeploymentsExportTemplateAtScopeOptionalParams,\n  DeploymentsExportTemplateAtScopeResponse,\n  DeploymentsDeleteAtTenantScopeOptionalParams,\n  DeploymentsCheckExistenceAtTenantScopeOptionalParams,\n  DeploymentsCheckExistenceAtTenantScopeResponse,\n  ScopedDeployment,\n  DeploymentsCreateOrUpdateAtTenantScopeOptionalParams,\n  DeploymentsCreateOrUpdateAtTenantScopeResponse,\n  DeploymentsGetAtTenantScopeOptionalParams,\n  DeploymentsGetAtTenantScopeResponse,\n  DeploymentsCancelAtTenantScopeOptionalParams,\n  DeploymentsValidateAtTenantScopeOptionalParams,\n  DeploymentsValidateAtTenantScopeResponse,\n  ScopedDeploymentWhatIf,\n  DeploymentsWhatIfAtTenantScopeOptionalParams,\n  DeploymentsWhatIfAtTenantScopeResponse,\n  DeploymentsExportTemplateAtTenantScopeOptionalParams,\n  DeploymentsExportTemplateAtTenantScopeResponse,\n  DeploymentsDeleteAtManagementGroupScopeOptionalParams,\n  DeploymentsCheckExistenceAtManagementGroupScopeOptionalParams,\n  DeploymentsCheckExistenceAtManagementGroupScopeResponse,\n  DeploymentsCreateOrUpdateAtManagementGroupScopeOptionalParams,\n  DeploymentsCreateOrUpdateAtManagementGroupScopeResponse,\n  DeploymentsGetAtManagementGroupScopeOptionalParams,\n  DeploymentsGetAtManagementGroupScopeResponse,\n  DeploymentsCancelAtManagementGroupScopeOptionalParams,\n  DeploymentsValidateAtManagementGroupScopeOptionalParams,\n  DeploymentsValidateAtManagementGroupScopeResponse,\n  DeploymentsWhatIfAtManagementGroupScopeOptionalParams,\n  DeploymentsWhatIfAtManagementGroupScopeResponse,\n  DeploymentsExportTemplateAtManagementGroupScopeOptionalParams,\n  DeploymentsExportTemplateAtManagementGroupScopeResponse,\n  DeploymentsDeleteAtSubscriptionScopeOptionalParams,\n  DeploymentsCheckExistenceAtSubscriptionScopeOptionalParams,\n  DeploymentsCheckExistenceAtSubscriptionScopeResponse,\n  DeploymentsCreateOrUpdateAtSubscriptionScopeOptionalParams,\n  DeploymentsCreateOrUpdateAtSubscriptionScopeResponse,\n  DeploymentsGetAtSubscriptionScopeOptionalParams,\n  DeploymentsGetAtSubscriptionScopeResponse,\n  DeploymentsCancelAtSubscriptionScopeOptionalParams,\n  DeploymentsValidateAtSubscriptionScopeOptionalParams,\n  DeploymentsValidateAtSubscriptionScopeResponse,\n  DeploymentWhatIf,\n  DeploymentsWhatIfAtSubscriptionScopeOptionalParams,\n  DeploymentsWhatIfAtSubscriptionScopeResponse,\n  DeploymentsExportTemplateAtSubscriptionScopeOptionalParams,\n  DeploymentsExportTemplateAtSubscriptionScopeResponse,\n  DeploymentsDeleteOptionalParams,\n  DeploymentsCheckExistenceOptionalParams,\n  DeploymentsCheckExistenceResponse,\n  DeploymentsCreateOrUpdateOptionalParams,\n  DeploymentsCreateOrUpdateResponse,\n  DeploymentsGetOptionalParams,\n  DeploymentsGetResponse,\n  DeploymentsCancelOptionalParams,\n  DeploymentsValidateOptionalParams,\n  DeploymentsValidateResponse,\n  DeploymentsWhatIfOptionalParams,\n  DeploymentsWhatIfResponse,\n  DeploymentsExportTemplateOptionalParams,\n  DeploymentsExportTemplateResponse,\n  DeploymentsCalculateTemplateHashOptionalParams,\n  DeploymentsCalculateTemplateHashResponse,\n  DeploymentsListAtScopeNextResponse,\n  DeploymentsListAtTenantScopeNextResponse,\n  DeploymentsListAtManagementGroupScopeNextResponse,\n  DeploymentsListAtSubscriptionScopeNextResponse,\n  DeploymentsListByResourceGroupNextResponse,\n} from \"../models/index.js\";\n\n/// <reference lib=\"esnext.asynciterable\" />\n/** Class containing Deployments operations. */\nexport class DeploymentsImpl implements Deployments {\n  private readonly client: ResourceManagementClient;\n\n  /**\n   * Initialize a new instance of the class Deployments class.\n   * @param client Reference to the service client\n   */\n  constructor(client: ResourceManagementClient) {\n    this.client = client;\n  }\n\n  /**\n   * Get all the deployments at the given scope.\n   * @param scope The resource scope.\n   * @param options The options parameters.\n   */\n  public listAtScope(\n    scope: string,\n    options?: DeploymentsListAtScopeOptionalParams,\n  ): PagedAsyncIterableIterator<DeploymentExtended> {\n    const iter = this.listAtScopePagingAll(scope, options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings?: PageSettings) => {\n        if (settings?.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listAtScopePagingPage(scope, options, settings);\n      },\n    };\n  }\n\n  private async *listAtScopePagingPage(\n    scope: string,\n    options?: DeploymentsListAtScopeOptionalParams,\n    settings?: PageSettings,\n  ): AsyncIterableIterator<DeploymentExtended[]> {\n    let result: DeploymentsListAtScopeResponse;\n    let continuationToken = settings?.continuationToken;\n    if (!continuationToken) {\n      result = await this._listAtScope(scope, options);\n      let page = result.value || [];\n      continuationToken = result.nextLink;\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n    while (continuationToken) {\n      result = await this._listAtScopeNext(scope, continuationToken, options);\n      continuationToken = result.nextLink;\n      let page = result.value || [];\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n  }\n\n  private async *listAtScopePagingAll(\n    scope: string,\n    options?: DeploymentsListAtScopeOptionalParams,\n  ): AsyncIterableIterator<DeploymentExtended> {\n    for await (const page of this.listAtScopePagingPage(scope, options)) {\n      yield* page;\n    }\n  }\n\n  /**\n   * Get all the deployments at the tenant scope.\n   * @param options The options parameters.\n   */\n  public listAtTenantScope(\n    options?: DeploymentsListAtTenantScopeOptionalParams,\n  ): PagedAsyncIterableIterator<DeploymentExtended> {\n    const iter = this.listAtTenantScopePagingAll(options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings?: PageSettings) => {\n        if (settings?.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listAtTenantScopePagingPage(options, settings);\n      },\n    };\n  }\n\n  private async *listAtTenantScopePagingPage(\n    options?: DeploymentsListAtTenantScopeOptionalParams,\n    settings?: PageSettings,\n  ): AsyncIterableIterator<DeploymentExtended[]> {\n    let result: DeploymentsListAtTenantScopeResponse;\n    let continuationToken = settings?.continuationToken;\n    if (!continuationToken) {\n      result = await this._listAtTenantScope(options);\n      let page = result.value || [];\n      continuationToken = result.nextLink;\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n    while (continuationToken) {\n      result = await this._listAtTenantScopeNext(continuationToken, options);\n      continuationToken = result.nextLink;\n      let page = result.value || [];\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n  }\n\n  private async *listAtTenantScopePagingAll(\n    options?: DeploymentsListAtTenantScopeOptionalParams,\n  ): AsyncIterableIterator<DeploymentExtended> {\n    for await (const page of this.listAtTenantScopePagingPage(options)) {\n      yield* page;\n    }\n  }\n\n  /**\n   * Get all the deployments for a management group.\n   * @param groupId The management group ID.\n   * @param options The options parameters.\n   */\n  public listAtManagementGroupScope(\n    groupId: string,\n    options?: DeploymentsListAtManagementGroupScopeOptionalParams,\n  ): PagedAsyncIterableIterator<DeploymentExtended> {\n    const iter = this.listAtManagementGroupScopePagingAll(groupId, options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings?: PageSettings) => {\n        if (settings?.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listAtManagementGroupScopePagingPage(\n          groupId,\n          options,\n          settings,\n        );\n      },\n    };\n  }\n\n  private async *listAtManagementGroupScopePagingPage(\n    groupId: string,\n    options?: DeploymentsListAtManagementGroupScopeOptionalParams,\n    settings?: PageSettings,\n  ): AsyncIterableIterator<DeploymentExtended[]> {\n    let result: DeploymentsListAtManagementGroupScopeResponse;\n    let continuationToken = settings?.continuationToken;\n    if (!continuationToken) {\n      result = await this._listAtManagementGroupScope(groupId, options);\n      let page = result.value || [];\n      continuationToken = result.nextLink;\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n    while (continuationToken) {\n      result = await this._listAtManagementGroupScopeNext(\n        groupId,\n        continuationToken,\n        options,\n      );\n      continuationToken = result.nextLink;\n      let page = result.value || [];\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n  }\n\n  private async *listAtManagementGroupScopePagingAll(\n    groupId: string,\n    options?: DeploymentsListAtManagementGroupScopeOptionalParams,\n  ): AsyncIterableIterator<DeploymentExtended> {\n    for await (const page of this.listAtManagementGroupScopePagingPage(\n      groupId,\n      options,\n    )) {\n      yield* page;\n    }\n  }\n\n  /**\n   * Get all the deployments for a subscription.\n   * @param options The options parameters.\n   */\n  public listAtSubscriptionScope(\n    options?: DeploymentsListAtSubscriptionScopeOptionalParams,\n  ): PagedAsyncIterableIterator<DeploymentExtended> {\n    const iter = this.listAtSubscriptionScopePagingAll(options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings?: PageSettings) => {\n        if (settings?.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listAtSubscriptionScopePagingPage(options, settings);\n      },\n    };\n  }\n\n  private async *listAtSubscriptionScopePagingPage(\n    options?: DeploymentsListAtSubscriptionScopeOptionalParams,\n    settings?: PageSettings,\n  ): AsyncIterableIterator<DeploymentExtended[]> {\n    let result: DeploymentsListAtSubscriptionScopeResponse;\n    let continuationToken = settings?.continuationToken;\n    if (!continuationToken) {\n      result = await this._listAtSubscriptionScope(options);\n      let page = result.value || [];\n      continuationToken = result.nextLink;\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n    while (continuationToken) {\n      result = await this._listAtSubscriptionScopeNext(\n        continuationToken,\n        options,\n      );\n      continuationToken = result.nextLink;\n      let page = result.value || [];\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n  }\n\n  private async *listAtSubscriptionScopePagingAll(\n    options?: DeploymentsListAtSubscriptionScopeOptionalParams,\n  ): AsyncIterableIterator<DeploymentExtended> {\n    for await (const page of this.listAtSubscriptionScopePagingPage(options)) {\n      yield* page;\n    }\n  }\n\n  /**\n   * Get all the deployments for a resource group.\n   * @param resourceGroupName The name of the resource group with the deployments to get. The name is\n   *                          case insensitive.\n   * @param options The options parameters.\n   */\n  public listByResourceGroup(\n    resourceGroupName: string,\n    options?: DeploymentsListByResourceGroupOptionalParams,\n  ): PagedAsyncIterableIterator<DeploymentExtended> {\n    const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings?: PageSettings) => {\n        if (settings?.maxPageSize) {\n          throw new Error(\"maxPageSize is not supported by this operation.\");\n        }\n        return this.listByResourceGroupPagingPage(\n          resourceGroupName,\n          options,\n          settings,\n        );\n      },\n    };\n  }\n\n  private async *listByResourceGroupPagingPage(\n    resourceGroupName: string,\n    options?: DeploymentsListByResourceGroupOptionalParams,\n    settings?: PageSettings,\n  ): AsyncIterableIterator<DeploymentExtended[]> {\n    let result: DeploymentsListByResourceGroupResponse;\n    let continuationToken = settings?.continuationToken;\n    if (!continuationToken) {\n      result = await this._listByResourceGroup(resourceGroupName, options);\n      let page = result.value || [];\n      continuationToken = result.nextLink;\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n    while (continuationToken) {\n      result = await this._listByResourceGroupNext(\n        resourceGroupName,\n        continuationToken,\n        options,\n      );\n      continuationToken = result.nextLink;\n      let page = result.value || [];\n      setContinuationToken(page, continuationToken);\n      yield page;\n    }\n  }\n\n  private async *listByResourceGroupPagingAll(\n    resourceGroupName: string,\n    options?: DeploymentsListByResourceGroupOptionalParams,\n  ): AsyncIterableIterator<DeploymentExtended> {\n    for await (const page of this.listByResourceGroupPagingPage(\n      resourceGroupName,\n      options,\n    )) {\n      yield* page;\n    }\n  }\n\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtScope(\n    scope: string,\n    deploymentName: string,\n    options?: DeploymentsDeleteAtScopeOptionalParams,\n  ): Promise<SimplePollerLike<OperationState<void>, void>> {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<void> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { scope, deploymentName, options },\n      spec: deleteAtScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<void, OperationState<void>>(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtScopeAndWait(\n    scope: string,\n    deploymentName: string,\n    options?: DeploymentsDeleteAtScopeOptionalParams,\n  ): Promise<void> {\n    const poller = await this.beginDeleteAtScope(\n      scope,\n      deploymentName,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Checks whether the deployment exists.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  checkExistenceAtScope(\n    scope: string,\n    deploymentName: string,\n    options?: DeploymentsCheckExistenceAtScopeOptionalParams,\n  ): Promise<DeploymentsCheckExistenceAtScopeResponse> {\n    return this.client.sendOperationRequest(\n      { scope, deploymentName, options },\n      checkExistenceAtScopeOperationSpec,\n    );\n  }\n\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtScope(\n    scope: string,\n    deploymentName: string,\n    parameters: Deployment,\n    options?: DeploymentsCreateOrUpdateAtScopeOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsCreateOrUpdateAtScopeResponse>,\n      DeploymentsCreateOrUpdateAtScopeResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsCreateOrUpdateAtScopeResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { scope, deploymentName, parameters, options },\n      spec: createOrUpdateAtScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsCreateOrUpdateAtScopeResponse,\n      OperationState<DeploymentsCreateOrUpdateAtScopeResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtScopeAndWait(\n    scope: string,\n    deploymentName: string,\n    parameters: Deployment,\n    options?: DeploymentsCreateOrUpdateAtScopeOptionalParams,\n  ): Promise<DeploymentsCreateOrUpdateAtScopeResponse> {\n    const poller = await this.beginCreateOrUpdateAtScope(\n      scope,\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Gets a deployment.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  getAtScope(\n    scope: string,\n    deploymentName: string,\n    options?: DeploymentsGetAtScopeOptionalParams,\n  ): Promise<DeploymentsGetAtScopeResponse> {\n    return this.client.sendOperationRequest(\n      { scope, deploymentName, options },\n      getAtScopeOperationSpec,\n    );\n  }\n\n  /**\n   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the\n   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment\n   * stops the currently running template deployment and leaves the resources partially deployed.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  cancelAtScope(\n    scope: string,\n    deploymentName: string,\n    options?: DeploymentsCancelAtScopeOptionalParams,\n  ): Promise<void> {\n    return this.client.sendOperationRequest(\n      { scope, deploymentName, options },\n      cancelAtScopeOperationSpec,\n    );\n  }\n\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtScope(\n    scope: string,\n    deploymentName: string,\n    parameters: Deployment,\n    options?: DeploymentsValidateAtScopeOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsValidateAtScopeResponse>,\n      DeploymentsValidateAtScopeResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsValidateAtScopeResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { scope, deploymentName, parameters, options },\n      spec: validateAtScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsValidateAtScopeResponse,\n      OperationState<DeploymentsValidateAtScopeResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtScopeAndWait(\n    scope: string,\n    deploymentName: string,\n    parameters: Deployment,\n    options?: DeploymentsValidateAtScopeOptionalParams,\n  ): Promise<DeploymentsValidateAtScopeResponse> {\n    const poller = await this.beginValidateAtScope(\n      scope,\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Exports the template used for specified deployment.\n   * @param scope The resource scope.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  exportTemplateAtScope(\n    scope: string,\n    deploymentName: string,\n    options?: DeploymentsExportTemplateAtScopeOptionalParams,\n  ): Promise<DeploymentsExportTemplateAtScopeResponse> {\n    return this.client.sendOperationRequest(\n      { scope, deploymentName, options },\n      exportTemplateAtScopeOperationSpec,\n    );\n  }\n\n  /**\n   * Get all the deployments at the given scope.\n   * @param scope The resource scope.\n   * @param options The options parameters.\n   */\n  private _listAtScope(\n    scope: string,\n    options?: DeploymentsListAtScopeOptionalParams,\n  ): Promise<DeploymentsListAtScopeResponse> {\n    return this.client.sendOperationRequest(\n      { scope, options },\n      listAtScopeOperationSpec,\n    );\n  }\n\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtTenantScope(\n    deploymentName: string,\n    options?: DeploymentsDeleteAtTenantScopeOptionalParams,\n  ): Promise<SimplePollerLike<OperationState<void>, void>> {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<void> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { deploymentName, options },\n      spec: deleteAtTenantScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<void, OperationState<void>>(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtTenantScopeAndWait(\n    deploymentName: string,\n    options?: DeploymentsDeleteAtTenantScopeOptionalParams,\n  ): Promise<void> {\n    const poller = await this.beginDeleteAtTenantScope(deploymentName, options);\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Checks whether the deployment exists.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  checkExistenceAtTenantScope(\n    deploymentName: string,\n    options?: DeploymentsCheckExistenceAtTenantScopeOptionalParams,\n  ): Promise<DeploymentsCheckExistenceAtTenantScopeResponse> {\n    return this.client.sendOperationRequest(\n      { deploymentName, options },\n      checkExistenceAtTenantScopeOperationSpec,\n    );\n  }\n\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtTenantScope(\n    deploymentName: string,\n    parameters: ScopedDeployment,\n    options?: DeploymentsCreateOrUpdateAtTenantScopeOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsCreateOrUpdateAtTenantScopeResponse>,\n      DeploymentsCreateOrUpdateAtTenantScopeResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsCreateOrUpdateAtTenantScopeResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { deploymentName, parameters, options },\n      spec: createOrUpdateAtTenantScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsCreateOrUpdateAtTenantScopeResponse,\n      OperationState<DeploymentsCreateOrUpdateAtTenantScopeResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtTenantScopeAndWait(\n    deploymentName: string,\n    parameters: ScopedDeployment,\n    options?: DeploymentsCreateOrUpdateAtTenantScopeOptionalParams,\n  ): Promise<DeploymentsCreateOrUpdateAtTenantScopeResponse> {\n    const poller = await this.beginCreateOrUpdateAtTenantScope(\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Gets a deployment.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  getAtTenantScope(\n    deploymentName: string,\n    options?: DeploymentsGetAtTenantScopeOptionalParams,\n  ): Promise<DeploymentsGetAtTenantScopeResponse> {\n    return this.client.sendOperationRequest(\n      { deploymentName, options },\n      getAtTenantScopeOperationSpec,\n    );\n  }\n\n  /**\n   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the\n   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment\n   * stops the currently running template deployment and leaves the resources partially deployed.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  cancelAtTenantScope(\n    deploymentName: string,\n    options?: DeploymentsCancelAtTenantScopeOptionalParams,\n  ): Promise<void> {\n    return this.client.sendOperationRequest(\n      { deploymentName, options },\n      cancelAtTenantScopeOperationSpec,\n    );\n  }\n\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtTenantScope(\n    deploymentName: string,\n    parameters: ScopedDeployment,\n    options?: DeploymentsValidateAtTenantScopeOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsValidateAtTenantScopeResponse>,\n      DeploymentsValidateAtTenantScopeResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsValidateAtTenantScopeResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { deploymentName, parameters, options },\n      spec: validateAtTenantScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsValidateAtTenantScopeResponse,\n      OperationState<DeploymentsValidateAtTenantScopeResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtTenantScopeAndWait(\n    deploymentName: string,\n    parameters: ScopedDeployment,\n    options?: DeploymentsValidateAtTenantScopeOptionalParams,\n  ): Promise<DeploymentsValidateAtTenantScopeResponse> {\n    const poller = await this.beginValidateAtTenantScope(\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the tenant group.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAtTenantScope(\n    deploymentName: string,\n    parameters: ScopedDeploymentWhatIf,\n    options?: DeploymentsWhatIfAtTenantScopeOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsWhatIfAtTenantScopeResponse>,\n      DeploymentsWhatIfAtTenantScopeResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsWhatIfAtTenantScopeResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { deploymentName, parameters, options },\n      spec: whatIfAtTenantScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsWhatIfAtTenantScopeResponse,\n      OperationState<DeploymentsWhatIfAtTenantScopeResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n      resourceLocationConfig: \"location\",\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the tenant group.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAtTenantScopeAndWait(\n    deploymentName: string,\n    parameters: ScopedDeploymentWhatIf,\n    options?: DeploymentsWhatIfAtTenantScopeOptionalParams,\n  ): Promise<DeploymentsWhatIfAtTenantScopeResponse> {\n    const poller = await this.beginWhatIfAtTenantScope(\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Exports the template used for specified deployment.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  exportTemplateAtTenantScope(\n    deploymentName: string,\n    options?: DeploymentsExportTemplateAtTenantScopeOptionalParams,\n  ): Promise<DeploymentsExportTemplateAtTenantScopeResponse> {\n    return this.client.sendOperationRequest(\n      { deploymentName, options },\n      exportTemplateAtTenantScopeOperationSpec,\n    );\n  }\n\n  /**\n   * Get all the deployments at the tenant scope.\n   * @param options The options parameters.\n   */\n  private _listAtTenantScope(\n    options?: DeploymentsListAtTenantScopeOptionalParams,\n  ): Promise<DeploymentsListAtTenantScopeResponse> {\n    return this.client.sendOperationRequest(\n      { options },\n      listAtTenantScopeOperationSpec,\n    );\n  }\n\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtManagementGroupScope(\n    groupId: string,\n    deploymentName: string,\n    options?: DeploymentsDeleteAtManagementGroupScopeOptionalParams,\n  ): Promise<SimplePollerLike<OperationState<void>, void>> {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<void> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { groupId, deploymentName, options },\n      spec: deleteAtManagementGroupScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<void, OperationState<void>>(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtManagementGroupScopeAndWait(\n    groupId: string,\n    deploymentName: string,\n    options?: DeploymentsDeleteAtManagementGroupScopeOptionalParams,\n  ): Promise<void> {\n    const poller = await this.beginDeleteAtManagementGroupScope(\n      groupId,\n      deploymentName,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Checks whether the deployment exists.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  checkExistenceAtManagementGroupScope(\n    groupId: string,\n    deploymentName: string,\n    options?: DeploymentsCheckExistenceAtManagementGroupScopeOptionalParams,\n  ): Promise<DeploymentsCheckExistenceAtManagementGroupScopeResponse> {\n    return this.client.sendOperationRequest(\n      { groupId, deploymentName, options },\n      checkExistenceAtManagementGroupScopeOperationSpec,\n    );\n  }\n\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtManagementGroupScope(\n    groupId: string,\n    deploymentName: string,\n    parameters: ScopedDeployment,\n    options?: DeploymentsCreateOrUpdateAtManagementGroupScopeOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsCreateOrUpdateAtManagementGroupScopeResponse>,\n      DeploymentsCreateOrUpdateAtManagementGroupScopeResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsCreateOrUpdateAtManagementGroupScopeResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { groupId, deploymentName, parameters, options },\n      spec: createOrUpdateAtManagementGroupScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsCreateOrUpdateAtManagementGroupScopeResponse,\n      OperationState<DeploymentsCreateOrUpdateAtManagementGroupScopeResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtManagementGroupScopeAndWait(\n    groupId: string,\n    deploymentName: string,\n    parameters: ScopedDeployment,\n    options?: DeploymentsCreateOrUpdateAtManagementGroupScopeOptionalParams,\n  ): Promise<DeploymentsCreateOrUpdateAtManagementGroupScopeResponse> {\n    const poller = await this.beginCreateOrUpdateAtManagementGroupScope(\n      groupId,\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Gets a deployment.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  getAtManagementGroupScope(\n    groupId: string,\n    deploymentName: string,\n    options?: DeploymentsGetAtManagementGroupScopeOptionalParams,\n  ): Promise<DeploymentsGetAtManagementGroupScopeResponse> {\n    return this.client.sendOperationRequest(\n      { groupId, deploymentName, options },\n      getAtManagementGroupScopeOperationSpec,\n    );\n  }\n\n  /**\n   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the\n   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment\n   * stops the currently running template deployment and leaves the resources partially deployed.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  cancelAtManagementGroupScope(\n    groupId: string,\n    deploymentName: string,\n    options?: DeploymentsCancelAtManagementGroupScopeOptionalParams,\n  ): Promise<void> {\n    return this.client.sendOperationRequest(\n      { groupId, deploymentName, options },\n      cancelAtManagementGroupScopeOperationSpec,\n    );\n  }\n\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtManagementGroupScope(\n    groupId: string,\n    deploymentName: string,\n    parameters: ScopedDeployment,\n    options?: DeploymentsValidateAtManagementGroupScopeOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsValidateAtManagementGroupScopeResponse>,\n      DeploymentsValidateAtManagementGroupScopeResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsValidateAtManagementGroupScopeResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { groupId, deploymentName, parameters, options },\n      spec: validateAtManagementGroupScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsValidateAtManagementGroupScopeResponse,\n      OperationState<DeploymentsValidateAtManagementGroupScopeResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtManagementGroupScopeAndWait(\n    groupId: string,\n    deploymentName: string,\n    parameters: ScopedDeployment,\n    options?: DeploymentsValidateAtManagementGroupScopeOptionalParams,\n  ): Promise<DeploymentsValidateAtManagementGroupScopeResponse> {\n    const poller = await this.beginValidateAtManagementGroupScope(\n      groupId,\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the management\n   * group.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAtManagementGroupScope(\n    groupId: string,\n    deploymentName: string,\n    parameters: ScopedDeploymentWhatIf,\n    options?: DeploymentsWhatIfAtManagementGroupScopeOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsWhatIfAtManagementGroupScopeResponse>,\n      DeploymentsWhatIfAtManagementGroupScopeResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsWhatIfAtManagementGroupScopeResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { groupId, deploymentName, parameters, options },\n      spec: whatIfAtManagementGroupScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsWhatIfAtManagementGroupScopeResponse,\n      OperationState<DeploymentsWhatIfAtManagementGroupScopeResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n      resourceLocationConfig: \"location\",\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the management\n   * group.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAtManagementGroupScopeAndWait(\n    groupId: string,\n    deploymentName: string,\n    parameters: ScopedDeploymentWhatIf,\n    options?: DeploymentsWhatIfAtManagementGroupScopeOptionalParams,\n  ): Promise<DeploymentsWhatIfAtManagementGroupScopeResponse> {\n    const poller = await this.beginWhatIfAtManagementGroupScope(\n      groupId,\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Exports the template used for specified deployment.\n   * @param groupId The management group ID.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  exportTemplateAtManagementGroupScope(\n    groupId: string,\n    deploymentName: string,\n    options?: DeploymentsExportTemplateAtManagementGroupScopeOptionalParams,\n  ): Promise<DeploymentsExportTemplateAtManagementGroupScopeResponse> {\n    return this.client.sendOperationRequest(\n      { groupId, deploymentName, options },\n      exportTemplateAtManagementGroupScopeOperationSpec,\n    );\n  }\n\n  /**\n   * Get all the deployments for a management group.\n   * @param groupId The management group ID.\n   * @param options The options parameters.\n   */\n  private _listAtManagementGroupScope(\n    groupId: string,\n    options?: DeploymentsListAtManagementGroupScopeOptionalParams,\n  ): Promise<DeploymentsListAtManagementGroupScopeResponse> {\n    return this.client.sendOperationRequest(\n      { groupId, options },\n      listAtManagementGroupScopeOperationSpec,\n    );\n  }\n\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtSubscriptionScope(\n    deploymentName: string,\n    options?: DeploymentsDeleteAtSubscriptionScopeOptionalParams,\n  ): Promise<SimplePollerLike<OperationState<void>, void>> {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<void> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { deploymentName, options },\n      spec: deleteAtSubscriptionScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<void, OperationState<void>>(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. This is an asynchronous operation that returns a\n   * status of 202 until the template deployment is successfully deleted. The Location response header\n   * contains the URI that is used to obtain the status of the process. While the process is running, a\n   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI\n   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the\n   * URI in the Location header returns an error-level status code.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAtSubscriptionScopeAndWait(\n    deploymentName: string,\n    options?: DeploymentsDeleteAtSubscriptionScopeOptionalParams,\n  ): Promise<void> {\n    const poller = await this.beginDeleteAtSubscriptionScope(\n      deploymentName,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Checks whether the deployment exists.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  checkExistenceAtSubscriptionScope(\n    deploymentName: string,\n    options?: DeploymentsCheckExistenceAtSubscriptionScopeOptionalParams,\n  ): Promise<DeploymentsCheckExistenceAtSubscriptionScopeResponse> {\n    return this.client.sendOperationRequest(\n      { deploymentName, options },\n      checkExistenceAtSubscriptionScopeOperationSpec,\n    );\n  }\n\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtSubscriptionScope(\n    deploymentName: string,\n    parameters: Deployment,\n    options?: DeploymentsCreateOrUpdateAtSubscriptionScopeOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsCreateOrUpdateAtSubscriptionScopeResponse>,\n      DeploymentsCreateOrUpdateAtSubscriptionScopeResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsCreateOrUpdateAtSubscriptionScopeResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { deploymentName, parameters, options },\n      spec: createOrUpdateAtSubscriptionScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsCreateOrUpdateAtSubscriptionScopeResponse,\n      OperationState<DeploymentsCreateOrUpdateAtSubscriptionScopeResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAtSubscriptionScopeAndWait(\n    deploymentName: string,\n    parameters: Deployment,\n    options?: DeploymentsCreateOrUpdateAtSubscriptionScopeOptionalParams,\n  ): Promise<DeploymentsCreateOrUpdateAtSubscriptionScopeResponse> {\n    const poller = await this.beginCreateOrUpdateAtSubscriptionScope(\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Gets a deployment.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  getAtSubscriptionScope(\n    deploymentName: string,\n    options?: DeploymentsGetAtSubscriptionScopeOptionalParams,\n  ): Promise<DeploymentsGetAtSubscriptionScopeResponse> {\n    return this.client.sendOperationRequest(\n      { deploymentName, options },\n      getAtSubscriptionScopeOperationSpec,\n    );\n  }\n\n  /**\n   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the\n   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment\n   * stops the currently running template deployment and leaves the resources partially deployed.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  cancelAtSubscriptionScope(\n    deploymentName: string,\n    options?: DeploymentsCancelAtSubscriptionScopeOptionalParams,\n  ): Promise<void> {\n    return this.client.sendOperationRequest(\n      { deploymentName, options },\n      cancelAtSubscriptionScopeOperationSpec,\n    );\n  }\n\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtSubscriptionScope(\n    deploymentName: string,\n    parameters: Deployment,\n    options?: DeploymentsValidateAtSubscriptionScopeOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsValidateAtSubscriptionScopeResponse>,\n      DeploymentsValidateAtSubscriptionScopeResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsValidateAtSubscriptionScopeResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { deploymentName, parameters, options },\n      spec: validateAtSubscriptionScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsValidateAtSubscriptionScopeResponse,\n      OperationState<DeploymentsValidateAtSubscriptionScopeResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAtSubscriptionScopeAndWait(\n    deploymentName: string,\n    parameters: Deployment,\n    options?: DeploymentsValidateAtSubscriptionScopeOptionalParams,\n  ): Promise<DeploymentsValidateAtSubscriptionScopeResponse> {\n    const poller = await this.beginValidateAtSubscriptionScope(\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the subscription.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to What If.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAtSubscriptionScope(\n    deploymentName: string,\n    parameters: DeploymentWhatIf,\n    options?: DeploymentsWhatIfAtSubscriptionScopeOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsWhatIfAtSubscriptionScopeResponse>,\n      DeploymentsWhatIfAtSubscriptionScopeResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsWhatIfAtSubscriptionScopeResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { deploymentName, parameters, options },\n      spec: whatIfAtSubscriptionScopeOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsWhatIfAtSubscriptionScopeResponse,\n      OperationState<DeploymentsWhatIfAtSubscriptionScopeResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n      resourceLocationConfig: \"location\",\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the subscription.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to What If.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAtSubscriptionScopeAndWait(\n    deploymentName: string,\n    parameters: DeploymentWhatIf,\n    options?: DeploymentsWhatIfAtSubscriptionScopeOptionalParams,\n  ): Promise<DeploymentsWhatIfAtSubscriptionScopeResponse> {\n    const poller = await this.beginWhatIfAtSubscriptionScope(\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Exports the template used for specified deployment.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  exportTemplateAtSubscriptionScope(\n    deploymentName: string,\n    options?: DeploymentsExportTemplateAtSubscriptionScopeOptionalParams,\n  ): Promise<DeploymentsExportTemplateAtSubscriptionScopeResponse> {\n    return this.client.sendOperationRequest(\n      { deploymentName, options },\n      exportTemplateAtSubscriptionScopeOperationSpec,\n    );\n  }\n\n  /**\n   * Get all the deployments for a subscription.\n   * @param options The options parameters.\n   */\n  private _listAtSubscriptionScope(\n    options?: DeploymentsListAtSubscriptionScopeOptionalParams,\n  ): Promise<DeploymentsListAtSubscriptionScopeResponse> {\n    return this.client.sendOperationRequest(\n      { options },\n      listAtSubscriptionScopeOperationSpec,\n    );\n  }\n\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. Deleting a template deployment does not affect the\n   * state of the resource group. This is an asynchronous operation that returns a status of 202 until\n   * the template deployment is successfully deleted. The Location response header contains the URI that\n   * is used to obtain the status of the process. While the process is running, a call to the URI in the\n   * Location header returns a status of 202. When the process finishes, the URI in the Location header\n   * returns a status of 204 on success. If the asynchronous request failed, the URI in the Location\n   * header returns an error-level status code.\n   * @param resourceGroupName The name of the resource group with the deployment to delete. The name is\n   *                          case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDelete(\n    resourceGroupName: string,\n    deploymentName: string,\n    options?: DeploymentsDeleteOptionalParams,\n  ): Promise<SimplePollerLike<OperationState<void>, void>> {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<void> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { resourceGroupName, deploymentName, options },\n      spec: deleteOperationSpec,\n    });\n    const poller = await createHttpPoller<void, OperationState<void>>(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * A template deployment that is currently running cannot be deleted. Deleting a template deployment\n   * removes the associated deployment operations. Deleting a template deployment does not affect the\n   * state of the resource group. This is an asynchronous operation that returns a status of 202 until\n   * the template deployment is successfully deleted. The Location response header contains the URI that\n   * is used to obtain the status of the process. While the process is running, a call to the URI in the\n   * Location header returns a status of 202. When the process finishes, the URI in the Location header\n   * returns a status of 204 on success. If the asynchronous request failed, the URI in the Location\n   * header returns an error-level status code.\n   * @param resourceGroupName The name of the resource group with the deployment to delete. The name is\n   *                          case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  async beginDeleteAndWait(\n    resourceGroupName: string,\n    deploymentName: string,\n    options?: DeploymentsDeleteOptionalParams,\n  ): Promise<void> {\n    const poller = await this.beginDelete(\n      resourceGroupName,\n      deploymentName,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Checks whether the deployment exists.\n   * @param resourceGroupName The name of the resource group with the deployment to check. The name is\n   *                          case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  checkExistence(\n    resourceGroupName: string,\n    deploymentName: string,\n    options?: DeploymentsCheckExistenceOptionalParams,\n  ): Promise<DeploymentsCheckExistenceResponse> {\n    return this.client.sendOperationRequest(\n      { resourceGroupName, deploymentName, options },\n      checkExistenceOperationSpec,\n    );\n  }\n\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param resourceGroupName The name of the resource group to deploy the resources to. The name is case\n   *                          insensitive. The resource group must already exist.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdate(\n    resourceGroupName: string,\n    deploymentName: string,\n    parameters: Deployment,\n    options?: DeploymentsCreateOrUpdateOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsCreateOrUpdateResponse>,\n      DeploymentsCreateOrUpdateResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsCreateOrUpdateResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { resourceGroupName, deploymentName, parameters, options },\n      spec: createOrUpdateOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsCreateOrUpdateResponse,\n      OperationState<DeploymentsCreateOrUpdateResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * You can provide the template and parameters directly in the request or link to JSON files.\n   * @param resourceGroupName The name of the resource group to deploy the resources to. The name is case\n   *                          insensitive. The resource group must already exist.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Additional parameters supplied to the operation.\n   * @param options The options parameters.\n   */\n  async beginCreateOrUpdateAndWait(\n    resourceGroupName: string,\n    deploymentName: string,\n    parameters: Deployment,\n    options?: DeploymentsCreateOrUpdateOptionalParams,\n  ): Promise<DeploymentsCreateOrUpdateResponse> {\n    const poller = await this.beginCreateOrUpdate(\n      resourceGroupName,\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Gets a deployment.\n   * @param resourceGroupName The name of the resource group. The name is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  get(\n    resourceGroupName: string,\n    deploymentName: string,\n    options?: DeploymentsGetOptionalParams,\n  ): Promise<DeploymentsGetResponse> {\n    return this.client.sendOperationRequest(\n      { resourceGroupName, deploymentName, options },\n      getOperationSpec,\n    );\n  }\n\n  /**\n   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the\n   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment\n   * stops the currently running template deployment and leaves the resource group partially deployed.\n   * @param resourceGroupName The name of the resource group. The name is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  cancel(\n    resourceGroupName: string,\n    deploymentName: string,\n    options?: DeploymentsCancelOptionalParams,\n  ): Promise<void> {\n    return this.client.sendOperationRequest(\n      { resourceGroupName, deploymentName, options },\n      cancelOperationSpec,\n    );\n  }\n\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param resourceGroupName The name of the resource group the template will be deployed to. The name\n   *                          is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidate(\n    resourceGroupName: string,\n    deploymentName: string,\n    parameters: Deployment,\n    options?: DeploymentsValidateOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsValidateResponse>,\n      DeploymentsValidateResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsValidateResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { resourceGroupName, deploymentName, parameters, options },\n      spec: validateOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsValidateResponse,\n      OperationState<DeploymentsValidateResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Validates whether the specified template is syntactically correct and will be accepted by Azure\n   * Resource Manager..\n   * @param resourceGroupName The name of the resource group the template will be deployed to. The name\n   *                          is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginValidateAndWait(\n    resourceGroupName: string,\n    deploymentName: string,\n    parameters: Deployment,\n    options?: DeploymentsValidateOptionalParams,\n  ): Promise<DeploymentsValidateResponse> {\n    const poller = await this.beginValidate(\n      resourceGroupName,\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the resource group.\n   * @param resourceGroupName The name of the resource group the template will be deployed to. The name\n   *                          is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginWhatIf(\n    resourceGroupName: string,\n    deploymentName: string,\n    parameters: DeploymentWhatIf,\n    options?: DeploymentsWhatIfOptionalParams,\n  ): Promise<\n    SimplePollerLike<\n      OperationState<DeploymentsWhatIfResponse>,\n      DeploymentsWhatIfResponse\n    >\n  > {\n    const directSendOperation = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ): Promise<DeploymentsWhatIfResponse> => {\n      return this.client.sendOperationRequest(args, spec);\n    };\n    const sendOperationFn = async (\n      args: coreClient.OperationArguments,\n      spec: coreClient.OperationSpec,\n    ) => {\n      let currentRawResponse: coreClient.FullOperationResponse | undefined =\n        undefined;\n      const providedCallback = args.options?.onResponse;\n      const callback: coreClient.RawResponseCallback = (\n        rawResponse: coreClient.FullOperationResponse,\n        flatResponse: unknown,\n      ) => {\n        currentRawResponse = rawResponse;\n        providedCallback?.(rawResponse, flatResponse);\n      };\n      const updatedArgs = {\n        ...args,\n        options: {\n          ...args.options,\n          onResponse: callback,\n        },\n      };\n      const flatResponse = await directSendOperation(updatedArgs, spec);\n      return {\n        flatResponse,\n        rawResponse: {\n          statusCode: currentRawResponse!.status,\n          body: currentRawResponse!.parsedBody,\n          headers: currentRawResponse!.headers.toJSON(),\n        },\n      };\n    };\n\n    const lro = createLroSpec({\n      sendOperationFn,\n      args: { resourceGroupName, deploymentName, parameters, options },\n      spec: whatIfOperationSpec,\n    });\n    const poller = await createHttpPoller<\n      DeploymentsWhatIfResponse,\n      OperationState<DeploymentsWhatIfResponse>\n    >(lro, {\n      restoreFrom: options?.resumeFrom,\n      intervalInMs: options?.updateIntervalInMs,\n      resourceLocationConfig: \"location\",\n    });\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Returns changes that will be made by the deployment if executed at the scope of the resource group.\n   * @param resourceGroupName The name of the resource group the template will be deployed to. The name\n   *                          is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param parameters Parameters to validate.\n   * @param options The options parameters.\n   */\n  async beginWhatIfAndWait(\n    resourceGroupName: string,\n    deploymentName: string,\n    parameters: DeploymentWhatIf,\n    options?: DeploymentsWhatIfOptionalParams,\n  ): Promise<DeploymentsWhatIfResponse> {\n    const poller = await this.beginWhatIf(\n      resourceGroupName,\n      deploymentName,\n      parameters,\n      options,\n    );\n    return poller.pollUntilDone();\n  }\n\n  /**\n   * Exports the template used for specified deployment.\n   * @param resourceGroupName The name of the resource group. The name is case insensitive.\n   * @param deploymentName The name of the deployment.\n   * @param options The options parameters.\n   */\n  exportTemplate(\n    resourceGroupName: string,\n    deploymentName: string,\n    options?: DeploymentsExportTemplateOptionalParams,\n  ): Promise<DeploymentsExportTemplateResponse> {\n    return this.client.sendOperationRequest(\n      { resourceGroupName, deploymentName, options },\n      exportTemplateOperationSpec,\n    );\n  }\n\n  /**\n   * Get all the deployments for a resource group.\n   * @param resourceGroupName The name of the resource group with the deployments to get. The name is\n   *                          case insensitive.\n   * @param options The options parameters.\n   */\n  private _listByResourceGroup(\n    resourceGroupName: string,\n    options?: DeploymentsListByResourceGroupOptionalParams,\n  ): Promise<DeploymentsListByResourceGroupResponse> {\n    return this.client.sendOperationRequest(\n      { resourceGroupName, options },\n      listByResourceGroupOperationSpec,\n    );\n  }\n\n  /**\n   * Calculate the hash of the given template.\n   * @param template The template provided to calculate hash.\n   * @param options The options parameters.\n   */\n  calculateTemplateHash(\n    template: Record<string, unknown>,\n    options?: DeploymentsCalculateTemplateHashOptionalParams,\n  ): Promise<DeploymentsCalculateTemplateHashResponse> {\n    return this.client.sendOperationRequest(\n      { template, options },\n      calculateTemplateHashOperationSpec,\n    );\n  }\n\n  /**\n   * ListAtScopeNext\n   * @param scope The resource scope.\n   * @param nextLink The nextLink from the previous successful call to the ListAtScope method.\n   * @param options The options parameters.\n   */\n  private _listAtScopeNext(\n    scope: string,\n    nextLink: string,\n    options?: DeploymentsListAtScopeNextOptionalParams,\n  ): Promise<DeploymentsListAtScopeNextResponse> {\n    return this.client.sendOperationRequest(\n      { scope, nextLink, options },\n      listAtScopeNextOperationSpec,\n    );\n  }\n\n  /**\n   * ListAtTenantScopeNext\n   * @param nextLink The nextLink from the previous successful call to the ListAtTenantScope method.\n   * @param options The options parameters.\n   */\n  private _listAtTenantScopeNext(\n    nextLink: string,\n    options?: DeploymentsListAtTenantScopeNextOptionalParams,\n  ): Promise<DeploymentsListAtTenantScopeNextResponse> {\n    return this.client.sendOperationRequest(\n      { nextLink, options },\n      listAtTenantScopeNextOperationSpec,\n    );\n  }\n\n  /**\n   * ListAtManagementGroupScopeNext\n   * @param groupId The management group ID.\n   * @param nextLink The nextLink from the previous successful call to the ListAtManagementGroupScope\n   *                 method.\n   * @param options The options parameters.\n   */\n  private _listAtManagementGroupScopeNext(\n    groupId: string,\n    nextLink: string,\n    options?: DeploymentsListAtManagementGroupScopeNextOptionalParams,\n  ): Promise<DeploymentsListAtManagementGroupScopeNextResponse> {\n    return this.client.sendOperationRequest(\n      { groupId, nextLink, options },\n      listAtManagementGroupScopeNextOperationSpec,\n    );\n  }\n\n  /**\n   * ListAtSubscriptionScopeNext\n   * @param nextLink The nextLink from the previous successful call to the ListAtSubscriptionScope\n   *                 method.\n   * @param options The options parameters.\n   */\n  private _listAtSubscriptionScopeNext(\n    nextLink: string,\n    options?: DeploymentsListAtSubscriptionScopeNextOptionalParams,\n  ): Promise<DeploymentsListAtSubscriptionScopeNextResponse> {\n    return this.client.sendOperationRequest(\n      { nextLink, options },\n      listAtSubscriptionScopeNextOperationSpec,\n    );\n  }\n\n  /**\n   * ListByResourceGroupNext\n   * @param resourceGroupName The name of the resource group with the deployments to get. The name is\n   *                          case insensitive.\n   * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.\n   * @param options The options parameters.\n   */\n  private _listByResourceGroupNext(\n    resourceGroupName: string,\n    nextLink: string,\n    options?: DeploymentsListByResourceGroupNextOptionalParams,\n  ): Promise<DeploymentsListByResourceGroupNextResponse> {\n    return this.client.sendOperationRequest(\n      { resourceGroupName, nextLink, options },\n      listByResourceGroupNextOperationSpec,\n    );\n  }\n}\n// Operation Specifications\nconst serializer = coreClient.createSerializer(Mappers, /* isXml */ false);\n\nconst deleteAtScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.scope,\n    Parameters.deploymentName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst checkExistenceAtScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"HEAD\",\n  responses: {\n    204: {},\n    404: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.scope,\n    Parameters.deploymentName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst createOrUpdateAtScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.scope,\n    Parameters.deploymentName,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst getAtScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.scope,\n    Parameters.deploymentName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst cancelAtScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel\",\n  httpMethod: \"POST\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.scope,\n    Parameters.deploymentName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst validateAtScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/validate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.scope,\n    Parameters.deploymentName,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst exportTemplateAtScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExportResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.scope,\n    Parameters.deploymentName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst listAtScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/{scope}/providers/Microsoft.Resources/deployments/\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],\n  urlParameters: [Parameters.$host, Parameters.scope],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst deleteAtTenantScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst checkExistenceAtTenantScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"HEAD\",\n  responses: {\n    204: {},\n    404: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst createOrUpdateAtTenantScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters1,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst getAtTenantScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst cancelAtTenantScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}/cancel\",\n  httpMethod: \"POST\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst validateAtTenantScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}/validate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters1,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst whatIfAtTenantScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    201: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    202: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    204: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters2,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst exportTemplateAtTenantScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExportResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host, Parameters.deploymentName],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst listAtTenantScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Resources/deployments/\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],\n  urlParameters: [Parameters.$host],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst deleteAtManagementGroupScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.groupId,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst checkExistenceAtManagementGroupScopeOperationSpec: coreClient.OperationSpec =\n  {\n    path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n    httpMethod: \"HEAD\",\n    responses: {\n      204: {},\n      404: {},\n      default: {\n        bodyMapper: Mappers.CloudError,\n      },\n    },\n    queryParameters: [Parameters.apiVersion],\n    urlParameters: [\n      Parameters.$host,\n      Parameters.deploymentName,\n      Parameters.groupId,\n    ],\n    headerParameters: [Parameters.accept],\n    serializer,\n  };\nconst createOrUpdateAtManagementGroupScopeOperationSpec: coreClient.OperationSpec =\n  {\n    path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n    httpMethod: \"PUT\",\n    responses: {\n      200: {\n        bodyMapper: Mappers.DeploymentExtended,\n      },\n      201: {\n        bodyMapper: Mappers.DeploymentExtended,\n      },\n      202: {\n        bodyMapper: Mappers.DeploymentExtended,\n      },\n      204: {\n        bodyMapper: Mappers.DeploymentExtended,\n      },\n      default: {\n        bodyMapper: Mappers.CloudError,\n      },\n    },\n    requestBody: Parameters.parameters1,\n    queryParameters: [Parameters.apiVersion],\n    urlParameters: [\n      Parameters.$host,\n      Parameters.deploymentName,\n      Parameters.groupId,\n    ],\n    headerParameters: [Parameters.accept, Parameters.contentType],\n    mediaType: \"json\",\n    serializer,\n  };\nconst getAtManagementGroupScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.groupId,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst cancelAtManagementGroupScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel\",\n  httpMethod: \"POST\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.groupId,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst validateAtManagementGroupScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters1,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.groupId,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst whatIfAtManagementGroupScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    201: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    202: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    204: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters2,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.groupId,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst exportTemplateAtManagementGroupScopeOperationSpec: coreClient.OperationSpec =\n  {\n    path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate\",\n    httpMethod: \"POST\",\n    responses: {\n      200: {\n        bodyMapper: Mappers.DeploymentExportResult,\n      },\n      default: {\n        bodyMapper: Mappers.CloudError,\n      },\n    },\n    queryParameters: [Parameters.apiVersion],\n    urlParameters: [\n      Parameters.$host,\n      Parameters.deploymentName,\n      Parameters.groupId,\n    ],\n    headerParameters: [Parameters.accept],\n    serializer,\n  };\nconst listAtManagementGroupScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],\n  urlParameters: [Parameters.$host, Parameters.groupId],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst deleteAtSubscriptionScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst checkExistenceAtSubscriptionScopeOperationSpec: coreClient.OperationSpec =\n  {\n    path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n    httpMethod: \"HEAD\",\n    responses: {\n      204: {},\n      404: {},\n      default: {\n        bodyMapper: Mappers.CloudError,\n      },\n    },\n    queryParameters: [Parameters.apiVersion],\n    urlParameters: [\n      Parameters.$host,\n      Parameters.deploymentName,\n      Parameters.subscriptionId,\n    ],\n    headerParameters: [Parameters.accept],\n    serializer,\n  };\nconst createOrUpdateAtSubscriptionScopeOperationSpec: coreClient.OperationSpec =\n  {\n    path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n    httpMethod: \"PUT\",\n    responses: {\n      200: {\n        bodyMapper: Mappers.DeploymentExtended,\n      },\n      201: {\n        bodyMapper: Mappers.DeploymentExtended,\n      },\n      202: {\n        bodyMapper: Mappers.DeploymentExtended,\n      },\n      204: {\n        bodyMapper: Mappers.DeploymentExtended,\n      },\n      default: {\n        bodyMapper: Mappers.CloudError,\n      },\n    },\n    requestBody: Parameters.parameters,\n    queryParameters: [Parameters.apiVersion],\n    urlParameters: [\n      Parameters.$host,\n      Parameters.deploymentName,\n      Parameters.subscriptionId,\n    ],\n    headerParameters: [Parameters.accept, Parameters.contentType],\n    mediaType: \"json\",\n    serializer,\n  };\nconst getAtSubscriptionScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst cancelAtSubscriptionScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel\",\n  httpMethod: \"POST\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst validateAtSubscriptionScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst whatIfAtSubscriptionScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    201: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    202: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    204: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters3,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst exportTemplateAtSubscriptionScopeOperationSpec: coreClient.OperationSpec =\n  {\n    path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate\",\n    httpMethod: \"POST\",\n    responses: {\n      200: {\n        bodyMapper: Mappers.DeploymentExportResult,\n      },\n      default: {\n        bodyMapper: Mappers.CloudError,\n      },\n    },\n    queryParameters: [Parameters.apiVersion],\n    urlParameters: [\n      Parameters.$host,\n      Parameters.deploymentName,\n      Parameters.subscriptionId,\n    ],\n    headerParameters: [Parameters.accept],\n    serializer,\n  };\nconst listAtSubscriptionScopeOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],\n  urlParameters: [Parameters.$host, Parameters.subscriptionId],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst deleteOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {},\n    201: {},\n    202: {},\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst checkExistenceOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"HEAD\",\n  responses: {\n    204: {},\n    404: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst createOrUpdateOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst getOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExtended,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst cancelOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel\",\n  httpMethod: \"POST\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst validateOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    201: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    202: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    204: {\n      bodyMapper: Mappers.DeploymentValidateResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst whatIfOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    201: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    202: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    204: {\n      bodyMapper: Mappers.WhatIfOperationResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.parameters3,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n  ],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst exportTemplateOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentExportResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.deploymentName,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst listByResourceGroupOperationSpec: coreClient.OperationSpec = {\n  path: \"/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],\n  urlParameters: [\n    Parameters.$host,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst calculateTemplateHashOperationSpec: coreClient.OperationSpec = {\n  path: \"/providers/Microsoft.Resources/calculateTemplateHash\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.TemplateHashResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  requestBody: Parameters.template,\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.$host],\n  headerParameters: [Parameters.accept, Parameters.contentType],\n  mediaType: \"json\",\n  serializer,\n};\nconst listAtScopeNextOperationSpec: coreClient.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.scope],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst listAtTenantScopeNextOperationSpec: coreClient.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  urlParameters: [Parameters.$host, Parameters.nextLink],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst listAtManagementGroupScopeNextOperationSpec: coreClient.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.groupId],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst listAtSubscriptionScopeNextOperationSpec: coreClient.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  urlParameters: [\n    Parameters.$host,\n    Parameters.nextLink,\n    Parameters.subscriptionId,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\nconst listByResourceGroupNextOperationSpec: coreClient.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeploymentListResult,\n    },\n    default: {\n      bodyMapper: Mappers.CloudError,\n    },\n  },\n  urlParameters: [\n    Parameters.$host,\n    Parameters.nextLink,\n    Parameters.subscriptionId,\n    Parameters.resourceGroupName,\n  ],\n  headerParameters: [Parameters.accept],\n  serializer,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}