{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isRestError, RestError } from \"../restError.js\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\nimport { createPipelineRequest } from \"../pipelineRequest.js\";\nimport { getCachedDefaultHttpsClient } from \"./clientHelpers.js\";\nimport { isReadableStream } from \"../util/typeGuards.js\";\nimport { buildMultipartBody } from \"./multipart.js\";\n/**\n * Helper function to send request used by the client\n * @param method - method to use to send the request\n * @param url - url to send the request to\n * @param pipeline - pipeline with the policies to run when sending the request\n * @param options - request options\n * @param customHttpClient - a custom HttpClient to use when making the request\n * @returns returns and HttpResponse\n */\nexport async function sendRequest(method, url, pipeline) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let customHttpClient = arguments.length > 4 ? arguments[4] : undefined;\n  var _a;\n  const httpClient = customHttpClient !== null && customHttpClient !== void 0 ? customHttpClient : getCachedDefaultHttpsClient();\n  const request = buildPipelineRequest(method, url, options);\n  try {\n    const response = await pipeline.sendRequest(httpClient, request);\n    const headers = response.headers.toJSON();\n    const stream = (_a = response.readableStreamBody) !== null && _a !== void 0 ? _a : response.browserStreamBody;\n    const parsedBody = options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);\n    const body = stream !== null && stream !== void 0 ? stream : parsedBody;\n    if (options === null || options === void 0 ? void 0 : options.onResponse) {\n      options.onResponse(Object.assign(Object.assign({}, response), {\n        request,\n        rawHeaders: headers,\n        parsedBody\n      }));\n    }\n    return {\n      request,\n      headers,\n      status: \"\".concat(response.status),\n      body\n    };\n  } catch (e) {\n    if (isRestError(e) && e.response && options.onResponse) {\n      const {\n        response\n      } = e;\n      const rawHeaders = response.headers.toJSON();\n      // UNBRANDED DIFFERENCE: onResponse callback does not have a second __legacyError property\n      options === null || options === void 0 ? void 0 : options.onResponse(Object.assign(Object.assign({}, response), {\n        request,\n        rawHeaders\n      }), e);\n    }\n    throw e;\n  }\n}\n/**\n * Function to determine the request content type\n * @param options - request options InternalRequestParameters\n * @returns returns the content-type\n */\nfunction getRequestContentType() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _a, _b, _c;\n  return (_c = (_a = options.contentType) !== null && _a !== void 0 ? _a : (_b = options.headers) === null || _b === void 0 ? void 0 : _b[\"content-type\"]) !== null && _c !== void 0 ? _c : getContentType(options.body);\n}\n/**\n * Function to determine the content-type of a body\n * this is used if an explicit content-type is not provided\n * @param body - body in the request\n * @returns returns the content-type\n */\nfunction getContentType(body) {\n  if (ArrayBuffer.isView(body)) {\n    return \"application/octet-stream\";\n  }\n  if (typeof body === \"string\") {\n    try {\n      JSON.parse(body);\n      return \"application/json\";\n    } catch (error) {\n      // If we fail to parse the body, it is not json\n      return undefined;\n    }\n  }\n  // By default return json\n  return \"application/json\";\n}\nfunction buildPipelineRequest(method, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a, _b, _c;\n  const requestContentType = getRequestContentType(options);\n  const {\n    body,\n    multipartBody\n  } = getRequestBody(options.body, requestContentType);\n  const hasContent = body !== undefined || multipartBody !== undefined;\n  const headers = createHttpHeaders(Object.assign(Object.assign(Object.assign({}, options.headers ? options.headers : {}), {\n    accept: (_c = (_a = options.accept) !== null && _a !== void 0 ? _a : (_b = options.headers) === null || _b === void 0 ? void 0 : _b.accept) !== null && _c !== void 0 ? _c : \"application/json\"\n  }), hasContent && requestContentType && {\n    \"content-type\": requestContentType\n  }));\n  return createPipelineRequest({\n    url,\n    method,\n    body,\n    multipartBody,\n    headers,\n    allowInsecureConnection: options.allowInsecureConnection,\n    abortSignal: options.abortSignal,\n    onUploadProgress: options.onUploadProgress,\n    onDownloadProgress: options.onDownloadProgress,\n    timeout: options.timeout,\n    enableBrowserStreams: true,\n    streamResponseStatusCodes: options.responseAsStream ? new Set([Number.POSITIVE_INFINITY]) : undefined\n  });\n}\n/**\n * Prepares the body before sending the request\n */\nfunction getRequestBody(body) {\n  let contentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  if (body === undefined) {\n    return {\n      body: undefined\n    };\n  }\n  if (typeof FormData !== \"undefined\" && body instanceof FormData) {\n    return {\n      body\n    };\n  }\n  if (isReadableStream(body)) {\n    return {\n      body\n    };\n  }\n  if (ArrayBuffer.isView(body)) {\n    return {\n      body: body instanceof Uint8Array ? body : JSON.stringify(body)\n    };\n  }\n  const firstType = contentType.split(\";\")[0];\n  switch (firstType) {\n    case \"application/json\":\n      return {\n        body: JSON.stringify(body)\n      };\n    case \"multipart/form-data\":\n      if (Array.isArray(body)) {\n        return {\n          multipartBody: buildMultipartBody(body)\n        };\n      }\n      return {\n        body: JSON.stringify(body)\n      };\n    case \"text/plain\":\n      return {\n        body: String(body)\n      };\n    default:\n      if (typeof body === \"string\") {\n        return {\n          body\n        };\n      }\n      return {\n        body: JSON.stringify(body)\n      };\n  }\n}\n/**\n * Prepares the response body\n */\nfunction getResponseBody(response) {\n  var _a, _b;\n  // Set the default response type\n  const contentType = (_a = response.headers.get(\"content-type\")) !== null && _a !== void 0 ? _a : \"\";\n  const firstType = contentType.split(\";\")[0];\n  const bodyToParse = (_b = response.bodyAsText) !== null && _b !== void 0 ? _b : \"\";\n  if (firstType === \"text/plain\") {\n    return String(bodyToParse);\n  }\n  // Default to \"application/json\" and fallback to string;\n  try {\n    return bodyToParse ? JSON.parse(bodyToParse) : undefined;\n  } catch (error) {\n    // If we were supposed to get a JSON object and failed to\n    // parse, throw a parse error\n    if (firstType === \"application/json\") {\n      throw createParseError(response, error);\n    }\n    // We are not sure how to handle the response so we return it as\n    // plain text.\n    return String(bodyToParse);\n  }\n}\nfunction createParseError(response, err) {\n  var _a;\n  const msg = \"Error \\\"\".concat(err, \"\\\" occurred while parsing the response body - \").concat(response.bodyAsText, \".\");\n  const errCode = (_a = err.code) !== null && _a !== void 0 ? _a : RestError.PARSE_ERROR;\n  return new RestError(msg, {\n    code: errCode,\n    statusCode: response.status,\n    request: response.request,\n    response: response\n  });\n}","map":{"version":3,"names":["isRestError","RestError","createHttpHeaders","createPipelineRequest","getCachedDefaultHttpsClient","isReadableStream","buildMultipartBody","sendRequest","method","url","pipeline","options","arguments","length","undefined","customHttpClient","httpClient","request","buildPipelineRequest","response","headers","toJSON","stream","_a","readableStreamBody","browserStreamBody","parsedBody","responseAsStream","getResponseBody","body","onResponse","Object","assign","rawHeaders","status","concat","e","getRequestContentType","_c","contentType","_b","getContentType","ArrayBuffer","isView","JSON","parse","error","requestContentType","multipartBody","getRequestBody","hasContent","accept","allowInsecureConnection","abortSignal","onUploadProgress","onDownloadProgress","timeout","enableBrowserStreams","streamResponseStatusCodes","Set","Number","POSITIVE_INFINITY","FormData","Uint8Array","stringify","firstType","split","Array","isArray","String","get","bodyToParse","bodyAsText","createParseError","err","msg","errCode","code","PARSE_ERROR","statusCode"],"sources":["/home/runner/work/Azure-Service-Deployment-Web/Azure-Service-Deployment-Web/node_modules/@typespec/ts-http-runtime/src/client/sendRequest.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  HttpClient,\n  HttpMethods,\n  MultipartRequestBody,\n  PipelineRequest,\n  PipelineResponse,\n  RequestBodyType,\n} from \"../interfaces.js\";\nimport { isRestError, RestError } from \"../restError.js\";\nimport type { Pipeline } from \"../pipeline.js\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\nimport { createPipelineRequest } from \"../pipelineRequest.js\";\nimport { getCachedDefaultHttpsClient } from \"./clientHelpers.js\";\nimport { isReadableStream } from \"../util/typeGuards.js\";\nimport type { HttpResponse, RequestParameters } from \"./common.js\";\nimport type { PartDescriptor } from \"./multipart.js\";\nimport { buildMultipartBody } from \"./multipart.js\";\n\n/**\n * Helper function to send request used by the client\n * @param method - method to use to send the request\n * @param url - url to send the request to\n * @param pipeline - pipeline with the policies to run when sending the request\n * @param options - request options\n * @param customHttpClient - a custom HttpClient to use when making the request\n * @returns returns and HttpResponse\n */\nexport async function sendRequest(\n  method: HttpMethods,\n  url: string,\n  pipeline: Pipeline,\n  options: InternalRequestParameters = {},\n  customHttpClient?: HttpClient,\n): Promise<HttpResponse> {\n  const httpClient = customHttpClient ?? getCachedDefaultHttpsClient();\n  const request = buildPipelineRequest(method, url, options);\n\n  try {\n    const response = await pipeline.sendRequest(httpClient, request);\n    const headers = response.headers.toJSON();\n    const stream = response.readableStreamBody ?? response.browserStreamBody;\n    const parsedBody =\n      options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);\n    const body = stream ?? parsedBody;\n\n    if (options?.onResponse) {\n      options.onResponse({ ...response, request, rawHeaders: headers, parsedBody });\n    }\n\n    return {\n      request,\n      headers,\n      status: `${response.status}`,\n      body,\n    };\n  } catch (e: unknown) {\n    if (isRestError(e) && e.response && options.onResponse) {\n      const { response } = e;\n      const rawHeaders = response.headers.toJSON();\n      // UNBRANDED DIFFERENCE: onResponse callback does not have a second __legacyError property\n      options?.onResponse({ ...response, request, rawHeaders }, e);\n    }\n\n    throw e;\n  }\n}\n\n/**\n * Function to determine the request content type\n * @param options - request options InternalRequestParameters\n * @returns returns the content-type\n */\nfunction getRequestContentType(options: InternalRequestParameters = {}): string {\n  return (\n    options.contentType ??\n    (options.headers?.[\"content-type\"] as string) ??\n    getContentType(options.body)\n  );\n}\n\n/**\n * Function to determine the content-type of a body\n * this is used if an explicit content-type is not provided\n * @param body - body in the request\n * @returns returns the content-type\n */\nfunction getContentType(body: any): string | undefined {\n  if (ArrayBuffer.isView(body)) {\n    return \"application/octet-stream\";\n  }\n\n  if (typeof body === \"string\") {\n    try {\n      JSON.parse(body);\n      return \"application/json\";\n    } catch (error: any) {\n      // If we fail to parse the body, it is not json\n      return undefined;\n    }\n  }\n  // By default return json\n  return \"application/json\";\n}\n\nexport interface InternalRequestParameters extends RequestParameters {\n  responseAsStream?: boolean;\n}\n\nfunction buildPipelineRequest(\n  method: HttpMethods,\n  url: string,\n  options: InternalRequestParameters = {},\n): PipelineRequest {\n  const requestContentType = getRequestContentType(options);\n  const { body, multipartBody } = getRequestBody(options.body, requestContentType);\n  const hasContent = body !== undefined || multipartBody !== undefined;\n\n  const headers = createHttpHeaders({\n    ...(options.headers ? options.headers : {}),\n    accept: options.accept ?? options.headers?.accept ?? \"application/json\",\n    ...(hasContent &&\n      requestContentType && {\n        \"content-type\": requestContentType,\n      }),\n  });\n\n  return createPipelineRequest({\n    url,\n    method,\n    body,\n    multipartBody,\n    headers,\n    allowInsecureConnection: options.allowInsecureConnection,\n    abortSignal: options.abortSignal,\n    onUploadProgress: options.onUploadProgress,\n    onDownloadProgress: options.onDownloadProgress,\n    timeout: options.timeout,\n    enableBrowserStreams: true,\n    streamResponseStatusCodes: options.responseAsStream\n      ? new Set([Number.POSITIVE_INFINITY])\n      : undefined,\n  });\n}\n\ninterface RequestBody {\n  body?: RequestBodyType;\n  multipartBody?: MultipartRequestBody;\n}\n\n/**\n * Prepares the body before sending the request\n */\nfunction getRequestBody(body?: unknown, contentType: string = \"\"): RequestBody {\n  if (body === undefined) {\n    return { body: undefined };\n  }\n\n  if (typeof FormData !== \"undefined\" && body instanceof FormData) {\n    return { body };\n  }\n\n  if (isReadableStream(body)) {\n    return { body };\n  }\n\n  if (ArrayBuffer.isView(body)) {\n    return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };\n  }\n\n  const firstType = contentType.split(\";\")[0];\n\n  switch (firstType) {\n    case \"application/json\":\n      return { body: JSON.stringify(body) };\n    case \"multipart/form-data\":\n      if (Array.isArray(body)) {\n        return { multipartBody: buildMultipartBody(body as PartDescriptor[]) };\n      }\n      return { body: JSON.stringify(body) };\n    case \"text/plain\":\n      return { body: String(body) };\n    default:\n      if (typeof body === \"string\") {\n        return { body };\n      }\n      return { body: JSON.stringify(body) };\n  }\n}\n\n/**\n * Prepares the response body\n */\nfunction getResponseBody(response: PipelineResponse): RequestBodyType | undefined {\n  // Set the default response type\n  const contentType = response.headers.get(\"content-type\") ?? \"\";\n  const firstType = contentType.split(\";\")[0];\n  const bodyToParse = response.bodyAsText ?? \"\";\n\n  if (firstType === \"text/plain\") {\n    return String(bodyToParse);\n  }\n  // Default to \"application/json\" and fallback to string;\n  try {\n    return bodyToParse ? JSON.parse(bodyToParse) : undefined;\n  } catch (error: any) {\n    // If we were supposed to get a JSON object and failed to\n    // parse, throw a parse error\n    if (firstType === \"application/json\") {\n      throw createParseError(response, error);\n    }\n\n    // We are not sure how to handle the response so we return it as\n    // plain text.\n    return String(bodyToParse);\n  }\n}\n\nfunction createParseError(response: PipelineResponse, err: any): RestError {\n  const msg = `Error \"${err}\" occurred while parsing the response body - ${response.bodyAsText}.`;\n  const errCode = err.code ?? RestError.PARSE_ERROR;\n  return new RestError(msg, {\n    code: errCode,\n    statusCode: response.status,\n    request: response.request,\n    response: response,\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}